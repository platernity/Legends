/****************************************
*	Legends 4v4 Competition title		*
*	Author:		Platernity				*
*	Contact:	platernity@hotmail.fr	*
****************************************/

#Extends "Modes/ShootMania/ModeBase.Script.txt"

#Const	CompatibleMapTypes	"LegendsArena"
#Const	Version				"1.0"



/* INCLUDES */
#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/Interface.Script.txt" as Interface
#Include "Libs/Nadeo/Victory.Script.txt" as Victory
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen
#Include "Libs/Nadeo/ShootMania/WarmUp.Script.txt" as WarmUp
#Include "Libs/Nadeo/ShootMania/ScoresTable.Script.txt" as ScoresTable
#Include "Libs/Nadeo/Layers.Script.txt" as Layers
#Include "Libs/Nadeo/Json.Script.txt" as Json

/* SETTINGS */
#Setting	S_FreeMode					True	as _("Free Mode")
#Setting	S_AttackTimeLimit			45		as _("Attack time limit")
#Setting	S_CaptureTimeLimit			15		as _("Capture time limit")
#Setting	S_CaptureTime				1.5		as _("Time to capture pole")
#Setting	S_WarmUpDuration			90		as _("Warmup duration")
#Setting	S_PointGapToWin				2		as _("Point gap to win map")
#Setting	S_PointLimitToWin			9		as _("Point limit to win map")
#Setting	S_MapsToWin					2		as _("Maps to win to win match")
#Setting 	S_PointLimitDecisiveRound	15		as _("Decisive point limit")
#Setting 	S_TimeBetweenRounds			5.		as _("Time between Rounds")
#Setting 	S_UsePlayerClublinks		True	as _("Use player clublinks")
#Setting 	S_UseLaserVsBullets			True	as _("Use laser vs rockets")
#Setting	S_UseAmmoBonusOnHit			True	as _("Use Ammo reload on hit")
#Setting 	S_AttackerPingTime			5		as _("Attacker ping time on hit")
#Setting 	S_DefenderRespawnTime		10		as _("Defender respawn time on hit (0=no respawn)")
#Setting	S_FriendlyFire				False	as _("Friendly fire")
#Setting	S_GetAPointForDefense		False	as _("Get a point for successfull defense")


//To be removed
#Setting	S_BlueBots			0		as _("Blue bots")
#Setting	S_RedBots			0		as _("Red bots")
#Setting	S_UseSimpleScore	False	as _("Use simple Score")

//* CONSTANTS */
#Const Description _("TYPE: Team versus Team (4 vs 4)\nOBJECTIVE:\nOne attacker plays against three defenders on each side. The attacker must capture the pole or eliminate the defenders. The defenders must eliminate the attacker or prevent him to capture the pole.\nThe attacker uses the Laser while the defenders have the Rocket.\nEach teams get 1 point for any successfull attack. First team to reach score limit win the map.\nWhen attacker hits the other attacker it pings him.\nWhen defender kills an opponent defender, he'll respawn.")
#Const DescriptionWithDefensePoints _("TYPE: Team versus Team (4 vs 4)\nOBJECTIVE:\nOne attacker plays against three defenders on each side. The attacker must capture the pole or eliminate the defenders. The defenders must eliminate the attacker or prevent him to capture the pole.\nThe attacker uses the Laser while the defenders have the Rocket.\nTeams get 1 point for a successfull attack and 1 point for a successfull defense. First team to reach score limit win the map.\nWhen attacker hits the other attacker it pings him.\nWhen defender kills an opponent defender, he'll respawn.")
#Const	C_PlayerNeeded	8 		//Number of players needed to start match
#Const	C_MaxPlayers	10		//Number of players max for a match (FreeMode)
#Const	C_NoWarmUp		False	//For testing purposes only
#Const	C_UseBots		True	//For testing purposes only
#Const	C_UsePlayLoopLogs False	//For testing purposes only
#Const	C_AttackerAmmoGain			1.0			// Attacker ammunition gain rate
#Const	C_DefenderAmmoGain			1.0			// Defender ammunition gain rate
#Const	C_DefStaminaMaxMultiplier	0.7			// Defender Stamina multiplier
#Const	C_AttackerArmorMultiplier	1			// Attacker armor per Defender.
#Const	C_DefenderArmor				1			// Defender armor
#Const	C_BigMessageTime			3000		// Time BigMessage stay
#Const	C_StatusMessageTime			2500		// Time StatusMessage stay
#Const	C_PoleUITime				1000		// Time PoleUI stay


#Const	C_UI_Colors [
	"BG"		=> "fffa",
	"Separator"	=> "eeef",
	"Text"		=> "fffc"
]

#Const C_SequenceWarmUp			1	///< Scores table mode warm up
#Const C_SequencePlaying		2	///< Scores table mode playing
#Const C_SequencePodium			3	///< Scores table mode podium

/* GLOBALES */
declare	Boolean G_CapturingPossible;			// Whether it's possible to capture the goal
declare	Ident[]	G_Team1Players;					// All players from Team 1
declare	Ident[]	G_Team2Players;					// All players from Team 2
declare	Ident[]	G_Team1DefenderPlayers;			// All defender players from Team 1
declare	Ident[]	G_Team2DefenderPlayers;			// All defender players from Team 
declare	Ident	G_Team1AttackingPlayer;			// Attacking player from Team 1
declare	Ident	G_Team2AttackingPlayer;			// Attacking player from Team 2
declare Integer	G_RoundCounter;					// Actual round played
declare Boolean	G_Pole1Captured;
declare Boolean	G_Pole2Captured;
declare Integer[Ident] G_DefenderTeam1TimeToBeRespawned;		//List Times for team 1 defenders to be respawned
declare Integer[Ident] G_DefenderTeam2TimeToBeRespawned;		//List Times for team 2 defenders to be respawned
declare Boolean G_Team1WonDefense;				//
declare Boolean G_Team2WonDefense;				//
declare Boolean	G_Team1WonAttack;				//
declare Boolean	G_Team2WonAttack;				//
declare Integer G_BlueBots;
declare Integer G_RedBots;
//declare CSmPlayer[]	G_PlayingPlayers;			//All Playing players
declare	Integer[Ident][Integer] G_MapOrder;		//Attack Order
declare Integer[Integer] G_InitDefHit;			///< Default values for the defenders hit
//declare Integer[Ident] G_AttackPoints;


//Scores
declare Integer[Integer] G_MapScores;			// Number of map won by each clan
declare Integer[Integer] G_RoundScores;			// Number of rounds won by each clan

//UI
declare CUILayer LayerScores;
declare CUILayer LayerTeams;
declare CUILayer LayerPosition;
declare CUILayer LayerInformation;
declare CUILayer LayerMarkers;
declare Text[] G_PlayingPlayersLogins;			// Logins of all currently playing players
declare Text G_LongestLaserName;				// Name of longest laser shooter
declare Real G_LongestLaserDist;				// Distance of longest laser shot
declare Integer G_LastBigMessage;				// Time of LastBigMessage
declare Integer G_LastStatusMessage;			// Time of LastStatusMessage
declare Integer G_LastPoleUI;					// Time of LastPoleUI
declare CSmPlayer[] G_LastPlayerPoleUI;			// Last Players needs PoleUIReset
declare Boolean	G_Playing;
declare Integer[Integer] G_AttackerMarkerTime;	// Time for Reset AttackerMarker
declare Boolean G_Team1MarkerCreated;
declare Boolean G_Team2MarkerCreated;

//Logs
declare Integer G_LogTime;

//SettingsCache
declare Boolean G_FreeMode;
declare Boolean	G_RestartNeeded;
declare Boolean G_UseLaserVsBullets;





/*****************************************************
	EXTENSIONS
*****************************************************/
***StartServer***
***
WarmUp::ResetOrder();
MB_UseSectionRound = True;
InitGameSettings();
***

***StartMap***
***
UIManager.UIAll.SendChat("$fffMap is loaded");
Mode::Ladder_OpenMatch_All();
InitUI();
InitLayers();
InitValues();
PrepareMatch();
InitBases();
InitPoles();
if(!C_NoWarmUp){
	StartWarmup();
}
***

***StartRound***
***
PrepareRound();
CheckWarmup();
SetTeams();
SetRoles();
SetSpawnsAndPoles();
AnnounceAttackers();
StartPlay();
G_LogTime=StartTime+1000;
G_Team1MarkerCreated=False;
G_Team2MarkerCreated=False;
***

***OnNewPlayer***
***
EditUI(Player);
EditValues(Player);
***

***OnNewSpectator***
***
PrepareUIForSpectator(Spectator);
***

***PlayLoop***
***
if(Now>=G_LogTime && C_UsePlayLoopLogs){
	G_LogTime+=3000;
	//logs
	log("playloop logs");
}
if(C_UseBots){
	if(G_BlueBots!=S_BlueBots){
		G_BlueBots=S_BlueBots;
		Users_SetNbFakeUsers(G_BlueBots,G_RedBots);
	}else if(G_RedBots!=S_RedBots){
		G_RedBots=S_RedBots;
		Users_SetNbFakeUsers(G_BlueBots,G_RedBots);
	}
}
UpdateUI();
SpawnPlayers();
HandlePendingEvents();
ActivateGoal();
CheckForCapture();
RespawnDefender();
SetPoints();
***

***EndRound***
***
AttributePoints();
DisplayResults();
CheckMapEnd();
***

***EndMap***
***
EndMapUI();
***

***EndServer***
***
Clean();
***

/*****************************************************
	FUNCTIONS
*****************************************************/
//Other
// Get region of users zone path

Text GetRegion(CUser _User) {
	if (_User == Null) {
		return "";
	}
	declare ZonePath = "";
	if (_User.ZonePath != "") {
		declare ExplodeZonePath = TextLib::Split("|", _User.ZonePath);
		if (ExplodeZonePath.existskey(1)) {
			ZonePath = ExplodeZonePath[1];
		}
	}
	if (ZonePath == "") {
		ZonePath = "Other";
	}
	return ZonePath;
}
/** Generate players list for the score table
 *
 *	@param	_Mode	The mode creating the list: 1 = Elite, 2 = Heroes
 *	@param	_Nb		Number of players in the list
 *	@param	_Scale	Width scale
 *
 *	@return	The players list Text
 */
Text CreatePlayersListBig(Integer _Mode, Real _Scale) {
	declare ML ="";
	declare PosX = 0.;
	declare PosY = 0.;
	declare Col = 2.;
	declare PlayersByCol1 = 0;
	declare PlayersByCol2 = 0;
	foreach(Player in Players){
		if(Player.RequestedClan == 1){
			PlayersByCol1 +=1;
		}else if(Player.RequestedClan == 2){
			PlayersByCol2 +=1;
		}
	}
	declare S = _Scale;
	declare K = 1;
	declare AvatarSize = 10.75;

	declare RocketHidden = 0;
	if (_Mode == 2) RocketHidden = 1;
	ML ^= """
<framemodel posn="0 0" id="Frame_PlayerLeft">
	<quad posn="0 0 2" sizen="{{{3*S}}} 11.5" image="file://Media/Manialinks/ShootMania/Elite/NotReady.dds" id="Quad_NotReady" />
	<quad posn="0 0 2" sizen="{{{3*S}}} 11.5" image="file://Media/Manialinks/ShootMania/Elite/Ready.dds" hidden="1" id="Quad_Ready" />
	<quad posn="{{{0*S}}} 0 1" sizen="{{{81.8*S}}} 11.5" bgcolor="a007" id="Quad_Attacker" hidden="1" />
	<quad posn="{{{0*S}}} 0 5" sizen="{{{81.8*S}}} 11.5" bgcolor="0009" id="Quad_Eliminated" hidden="1" />
	<quad posn="{{{(3*S)+6}}} {{{11.5/-2.}}} 2" sizen="{{{AvatarSize}}} {{{AvatarSize}}}" halign="center" valign="center" bgcolor="0003" opacity="0.9" id="Quad_Avatar" />
	<label posn="{{{17*S}}} -6.4 3" sizen="{{{45*S}}} 12" textsize="3" valign="bottom" id="Label_Name" />
	<label posn="{{{17*S}}} -10.4 3" sizen="{{{24*S}}} 5" textsize="1" valign="bottom" textemboss="1" id="Label_Rank" />
	<frame posn="{{{14.6*S}}} -2.7 4" id="Frame_Stars">
		<quad posn="0 0" sizen="2 2" valign="center" style="BgRaceScore2" substyle="Fame" id="Quad_Star_5" hidden="1" />
		<quad posn="0 -1.5" sizen="2 2" valign="center" style="BgRaceScore2" substyle="Fame" id="Quad_Star_4" hidden="1" />
		<quad posn="0 -3" sizen="2 2" valign="center" style="BgRaceScore2" substyle="Fame" id="Quad_Star_3" hidden="1" />
		<quad posn="0 -4.5" sizen="2 2" valign="center" style="BgRaceScore2" substyle="Fame" id="Quad_Star_2" hidden="1" />
		<quad posn="0 -6" sizen="2 2" valign="center" style="BgRaceScore2" substyle="Fame" id="Quad_Star_1" hidden="1" />
	</frame>
	<frame posn="{{{63*S}}} -10.4 2" id="Frame_LadderPoints" hidden="1">
		<quad posn="0 -2" sizen="{{{7*S}}} 7" halign="right" valign="bottom" style="Icons128x128_1" substyle="LadderPoints" />
		<label posn="-8 0" sizen="{{{12*S}}} 5" textsize="1" textcolor="bb8" halign="right" valign="bottom" id="Label_LadderPoints" />
	</frame>
	<frame posn="{{{70*S}}} -5.5 2" id="Frame_DefPointsSimple">
		<label posn="0 0" sizen="{{{5*S}}} 3" textsize="2" halign="left" valign="center" id="Label_DefPoints" />
		<quad posn="-0.5 -0.2" sizen="5 5" halign="right" valign="center" image="file://Media/Manialinks/ShootMania/Common/Rocket.dds" hidden="{{{RocketHidden}}}" />
	</frame>
	<frame posn="{{{70*S}}} 0 2" id="Frame_DefPointsDetailed" hidden="1">
		<label posn="0 -1.75" sizen="{{{5*S}}} 3" textsize="2" halign="left" valign="center" id="Label_DefLaser" />
		<label posn="0 -5.25" sizen="{{{5*S}}} 3" textsize="2" halign="left" valign="center" id="Label_DefRocket" />
		<label posn="0 -8.75" sizen="{{{5*S}}} 3" textsize="2" halign="left" valign="center" id="Label_DefNucleus" />
		<quad posn="-0.5 -1.95" sizen="3 3" halign="right" valign="center" image="file://Media/Manialinks/ShootMania/Common/Laser.dds" />
		<quad posn="-0.5 -5.45" sizen="3 3" halign="right" valign="center" image="file://Media/Manialinks/ShootMania/Common/Rocket.dds" />
		<quad posn="-0.5 -8.95" sizen="3 3" halign="right" valign="center" image="file://Media/Manialinks/ShootMania/Common/Nucleus.dds" />
	</frame>
	<label posn="{{{76*S}}} -5.5 3" sizen="{{{5*S}}} 5" textsize="5" halign="left" valign="center" id="Label_AtkPoints" />
</framemodel>
<framemodel posn="0 0" id="Frame_PlayerRight">
	<quad posn="0 0 2" sizen="{{{3*S}}} 11.5" halign="right" image="file://Media/Manialinks/ShootMania/Elite/NotReady.dds" id="Quad_NotReady" />
	<quad posn="0 0 2" sizen="{{{3*S}}} 11.5" halign="right" image="file://Media/Manialinks/ShootMania/Elite/Ready.dds" hidden="1" id="Quad_Ready" />
	<quad posn="{{{0*S}}} 0 1" sizen="{{{81.8*S}}} 11.5" bgcolor="a007" halign="right" id="Quad_Attacker" hidden="1" />
	<quad posn="{{{0*S}}} 0 5" sizen="{{{81.8*S}}} 11.5" bgcolor="0009" halign="right" id="Quad_Eliminated" hidden="1" />
	<quad posn="{{{(-3*S)-6}}} {{{11.5/-2.}}} 2" sizen="{{{AvatarSize}}} {{{AvatarSize}}}" halign="center" valign="center" bgcolor="0003" opacity="0.9" id="Quad_Avatar" />
	<label posn="{{{-17*S}}} -6.4 3" sizen="{{{45*S}}} 12" textsize="3" halign="right" valign="bottom" id="Label_Name" />
	<label posn="{{{-17*S}}} -10.4 3" sizen="{{{24*S}}} 5" textsize="1" halign="right" valign="bottom" textemboss="1" id="Label_Rank" />
	<frame posn="{{{-14.6*S}}} -2.7 4" id="Frame_Stars">
		<quad posn="0 0" sizen="2 2" halign="right" valign="center" style="BgRaceScore2" substyle="Fame" id="Quad_Star_5" hidden="1" />
		<quad posn="0 -1.5" sizen="2 2" halign="right" valign="center" style="BgRaceScore2" substyle="Fame" id="Quad_Star_4" hidden="1" />
		<quad posn="0 -3" sizen="2 2" halign="right" valign="center" style="BgRaceScore2" substyle="Fame" id="Quad_Star_3" hidden="1" />
		<quad posn="0 -4.5" sizen="2 2" halign="right" valign="center" style="BgRaceScore2" substyle="Fame" id="Quad_Star_2" hidden="1" />
		<quad posn="0 -6" sizen="2 2" halign="right" valign="center" style="BgRaceScore2" substyle="Fame" id="Quad_Star_1" hidden="1" />
	</frame>
	<frame posn="{{{-63*S}}} -10.4 2" id="Frame_LadderPoints" hidden="1">
		<quad posn="{{{13*S}}} -2" sizen="{{{7*S}}} 7" valign="bottom" style="Icons128x128_1" substyle="LadderPoints" />
		<label posn="{{{12*S}}} 0" sizen="{{{12*S}}} 5" textsize="1" textcolor="bb8" halign="right" valign="bottom" id="Label_LadderPoints" />
	</frame>
	<frame posn="{{{-70*S}}} -5.5 2" id="Frame_DefPointsSimple">
		<label posn="0 0" sizen="{{{5*S}}} 3" textsize="2" halign="right" valign="center" id="Label_DefPoints" />
		<quad posn="0.5 -0.2" sizen="5 5" halign="left" valign="center" image="file://Media/Manialinks/ShootMania/Common/Rocket2.dds" hidden="{{{RocketHidden}}}" />
	</frame>
	<frame posn="{{{-70*S}}} 0 2"id="Frame_DefPointsDetailed" hidden="1">
		<label posn="0 -1.75" sizen="{{{5*S}}} 3" textsize="2" halign="right" valign="center" id="Label_DefLaser" />
		<label posn="0 -5.25" sizen="{{{5*S}}} 3" textsize="2" halign="right" valign="center" id="Label_DefRocket" />
		<label posn="0 -8.75" sizen="{{{5*S}}} 3" textsize="2" halign="right" valign="center" id="Label_DefNucleus" />
		<quad posn="0.5 -1.95" sizen="3 3" halign="left" valign="center" image="file://Media/Manialinks/ShootMania/Common/Laser.dds" />
		<quad posn="0.5 -5.45" sizen="3 3" halign="left" valign="center" image="file://Media/Manialinks/ShootMania/Common/Rocket.dds" />
		<quad posn="0.5 -8.95" sizen="3 3" halign="left" valign="center" image="file://Media/Manialinks/ShootMania/Common/Nucleus.dds" />
	</frame>
	<label posn="{{{-76*S}}} -5.5 3" sizen="{{{5*S}}} 5" textsize="5" halign="right" valign="center" id="Label_AtkPoints" />
</framemodel>
""";
	declare BgColor = C_UI_Colors["BG"];
	if (_Mode == 2) BgColor = "667c";

	for (I, 1, PlayersByCol1) {
	
				ML ^= """<frame posn="{{{PosX}}} {{{PosY}}}">
	<quad posn="0 0 -6" sizen="{{{81.8*S}}} 11.5" bgcolor="{{{BgColor}}}" />
	<frameinstance modelid="Frame_PlayerLeft" id="Frame_Player_{{{K}}}" />
</frame>
""";
PosY -= 11.9;
K += 1;
}
PosY =0.;
PosX += 164*S/2.;
for (I, 1, PlayersByCol2) {
				ML ^= """
<frame posn="{{{PosX+(164*S/2.)}}} {{{PosY}}}">
	<quad posn="0 0 -6" sizen="{{{81.8*S}}} 11.5" bgcolor="{{{BgColor}}}" halign="right" />
	<frameinstance modelid="Frame_PlayerRight" id="Frame_Player_{{{K}}}" />
</frame>
""";
K += 1;
PosY -= 11.9;
}

	return ML;
}

/** Create the score table manialink string.
 * 
 * @return		The manialink string
 */
Text CreateLayerScoresTable() {
	declare TableWidth = 190;
	declare RowHeight = 10;
	
	declare Column = 0;
	declare Row = 0;
	declare Rank = 1;

declare Team1Color = """{{{Teams[0].ColorPrimary.X}}} {{{Teams[0].ColorPrimary.Y}}} {{{Teams[0].ColorPrimary.Z}}}""";
declare Team2Color = """{{{Teams[1].ColorPrimary.X}}} {{{Teams[1].ColorPrimary.Y}}} {{{Teams[1].ColorPrimary.Z}}}""";

declare ManiaLink = """<script><!--
			main() {
				while (True) {
					yield;
					if (InputPlayer == Null) continue;
					if (!PageIsVisible) continue;
					if (PrevServerName != CurrentServerName) {
						PrevServerName = CurrentServerName;
						Label_ServerName.SetText(TextLib::Compose("%1: $<%2$>", _("Server"), CurrentServerName));
					}
					foreach (Event in PendingEvents) {
						switch (Event.Type) {
							case CMlEvent::Type::MouseClick: {
								ShowProfile(Event.ControlId);
							}
						}
					}
				}
			}
		--></script>
		<frame posn="0 7">
			<quad posn="0 -2" sizen="{{{TableWidth}}} 195" image="file://Media/Manialinks/Shootmania/Common/topsBg.dds" halign="center" valign="center"/>
			<label posn="0 30.5" textprefix="$o" text="Rankings" scale="1.2" halign="center" valign="center"/>
			<label posn="{{{-TableWidth*0.45}}} 32.5" text="Points Limit: {{{S_PointLimitToWin}}}" scale="0.55" halign="left" valign="top"/>
			
			<label posn="{{{-TableWidth*0.10}}} 24" text="Def" scale="0.45" halign="center" valign="bottom"/>
			<label posn="{{{-TableWidth*0.03}}} 24" text="Atk" scale="0.45" halign="center" valign="bottom"/>
			
			<label posn="{{{TableWidth*0.35}}} 24" text="Def" scale="0.45" halign="center" valign="bottom"/>
			<label posn="{{{TableWidth*0.42}}} 24" text="Atk" scale="0.45" halign="center" valign="bottom"/>""";
			
	
			foreach (Score in Scores) {
				declare PlayerClan for Score.User = 0;
				declare Text BGColor1;
				declare Text BGColor2;
				switch (PlayerClan) {
					case 1: {
						BGColor1 = "118";
						BGColor2 = "226";
					}
					case 2: {
						BGColor1 = "811";
						BGColor2 = "622";
					}
					default: {
						BGColor1 = "000";
						BGColor2 = "000";
					}
				}
				Column = 0;
				if (Rank > 0.5 * (Scores.count + 1.0)) {
					Column = 1;
				} 
				Row = Rank - 1 - Column*((Scores.count+1)/2);
		
				ManiaLink ^= """<frame posn="{{{(-1+Column)*TableWidth*0.45}}} {{{19-Row*RowHeight}}}">
				<quad posn="0 0" sizen="{{{RowHeight*0.95}}} {{{RowHeight*0.95}}}" bgcolor="{{{BGColor1}}}c" halign="left" valign="center"/>
				<label posn="{{{RowHeight*0.46}}} 0.5" text="{{{Rank}}}." scale="1.2" halign="center" valign="center"/>
				
				<quad posn="{{{RowHeight*0.9+0.1}}} 0" sizen="{{{TableWidth*0.4}}} {{{RowHeight*0.95}}}" bgcolor="{{{BGColor2}}}9" halign="left" valign="center" id="{{{Score.User.Login}}}" scriptevents="1"/>
				<label posn="{{{RowHeight*0.9+2}}} {{{RowHeight*0.2}}}" sizen="{{{TableWidth*0.3}}} {{{RowHeight*0.8}}}" text="{{{Score.User.Name}}}" halign="left" valign="center"/>
				<label posn="{{{RowHeight*0.9+2}}} {{{-RowHeight*0.4}}}" sizen="{{{TableWidth*0.3}}} {{{RowHeight*0.2}}}" text="Rank: {{{Score.User.LadderRank}}} ({{{GetRegion(Score.User)}}})" scale="0.45" halign="left" valign="bottom"/>
				""";
		declare DefendHits for Score = 0;
		ManiaLink ^= """
			<label posn="{{{TableWidth*0.35+0.35}}} 0.5" textprefix="$5bf" text="{{{DefendHits}}}" scale="0.9" halign="center" valign="center"/>
			""";
		ManiaLink ^= """
			<label posn="{{{TableWidth*0.42+0.35}}} 0.5" text="{{{Score.Points}}}" scale="1.2" halign="center" valign="center"/>
			</frame>""";

		Rank += 1;
		if (Rank > 16) {
			break;
		}
	}
	
	if (G_LongestLaserName != "") {
		ManiaLink ^= """
			<label posn="{{{-TableWidth*0.45}}} -59.5" text="Longest Laser: {{{G_LongestLaserDist}}}m by {{{G_LongestLaserName}}}" scale="0.65" halign="left" valign="center"/>""";
	}
	
	ManiaLink ^= """
		</frame>""";
		return ManiaLink;
}
/** Create the score table manialink string (From Elite)
 * 
 * @return		The manialink string
 */
Text CreateLayerScoresTableElite() {
declare CW = 1.;
declare SW = 1.;

declare Team1Color = """{{{Teams[0].ColorPrimary.X}}} {{{Teams[0].ColorPrimary.Y}}} {{{Teams[0].ColorPrimary.Z}}}""";
declare Team2Color = """{{{Teams[1].ColorPrimary.X}}} {{{Teams[1].ColorPrimary.Y}}} {{{Teams[1].ColorPrimary.Z}}}""";
declare Team1PlayerCount = 0;
declare Team2PlayerCount = 0;
foreach(Player in Players){
	if(Player.CurrentClan==1){
		Team1PlayerCount+=1;
	}else if(Player.CurrentClan==2){
		Team2PlayerCount+=1;
	}
}
declare Integer Height;
if(Team1PlayerCount>=Team2PlayerCount) Height = 30+20*Team1PlayerCount;
else Height = 30+25*Team2PlayerCount;
if(Height<90) Height = 90;

declare TeamTextPosition =((Height/90.)-1)*4.;
declare BottomTextPosition=0;
if(Team1PlayerCount<=3 && Team2PlayerCount<=3) BottomTextPosition = -32;
if(Team1PlayerCount==4 || Team2PlayerCount==4) BottomTextPosition = -45;
if(Team1PlayerCount==5 || Team2PlayerCount==5) BottomTextPosition = -56;


declare ManiaLink= """
<quad posn="0 {{{-0.5*Height/90}}} -1" sizen="237 {{{Height}}}" halign="center" valign="center" image="file://Media/Manialinks/ShootMania/Elite/interface_elite_bg.dds" />
<quad posn="-73.2 {{{11*Height/90}}} 6" sizen="29 {{{44.3*Height*1.1/(96)}}}" halign="center" valign="center" image="file://Media/Manialinks/ShootMania/Elite/interface_elite_left.dds" colorize="{{{Team1Color}}}" />
<quad posn=" 73.2 {{{11*Height/90}}} 6" sizen="29 {{{44.3*Height*1.1/(96)}}}" halign="center" valign="center" image="file://Media/Manialinks/ShootMania/Elite/interface_elite_right.dds" colorize="{{{Team2Color}}}" />

<!--<quad posn="-150 {{{Height}}}" sizen="{{{50*CW}}} 20" halign="left" valign="top" style="TitleLogos" substyle="Title"/>-->

<!-- **************** Scores table **************** -->
<frame posn="0 {{{34*Height/140}}}" id ="Frame_ScoresTable">
	<!-- **************** Center panel **************** -->
	<frame posn="0 0">		
		<!-- **************** VS **************** -->
		<frame posn="0 0" id="Frame_VS">
			<quad posn="-7 -2.5" sizen="{{{15*Height/90}}} {{{15*Height/90}}}" halign="right" valign="bottom" style="Emblems" substyle="#1" />
			<quad posn="7 -2.5" sizen="{{{15*Height/90}}} {{{15*Height/90}}}" valign="bottom" style="Emblems" substyle="#2" />
			<label posn="-46 {{{2.5+TeamTextPosition}}}" sizen="46 5" textsize="4" halign="center" valign="bottom" scale="0.95" opacity="0.88" textemboss="1" id="Label_NameTeam1" />
			<label posn=" 46 {{{2.5+TeamTextPosition}}}" sizen="46 5" textsize="4" halign="center" valign="bottom" scale="0.95" opacity="0.88" textemboss="1" id="Label_NameTeam2" />
		</frame>
		<!-- **************** Players Ranking **************** -->
		<frame posn="{{{-164*CW/2.}}} {{{0}}}" id="Frame_Ranking">
			{{{CreatePlayersListBig(1, CW)}}}
		</frame>
	</frame>	
	<!-- **************** Bottom panels **************** -->
	<frame posn="{{{-164*CW/2.}}} {{{BottomTextPosition}}}">
		<!-- **************** Laser stats **************** -->
		<quad posn="{{{1*SW}}} -8.2" sizen="4 4" halign="left" valign="center" image="file://Media/Manialinks/ShootMania/Common/Laser.dds" />
		<label posn="{{{6*SW}}} -8" sizen="{{{75*SW}}} 6" textsize="2" textcolor="{{{C_UI_Colors["Text"]}}}" valign="center" textemboss="1" text="{{{TextLib::Compose(_("Longest Laser: %1 by %2"), "-", "-")}}}" id="Label_LongestLaser" />
		<!-- **************** Server info **************** -->
		<label posn="{{{158*CW}}} -8" sizen="{{{75*SW}}} 5" textsize="2" textcolor="{{{C_UI_Colors["Text"]}}}" halign="right" valign="center" textemboss="1" text="{{{TextLib::Compose("%1: $<%2$>", _("Server"), "-")}}}" id="Label_ServerName" />
		<quad posn="{{{163*SW}}} -8.2" sizen="4 4" halign="right" valign="center" image="file://Media/Manialinks/ShootMania/Common/Home.dds" />
		<!-- **************** Game info **************** -->
		<quad posn="{{{0.7*SW}}} -13.7" sizen="5 5" halign="left" valign="center" style="UIConstructionSimple_Buttons" substyle="Tools" />
		<label posn="{{{6*SW}}} -13.5" sizen="{{{75*SW}}} 6" textsize="2" textcolor="{{{C_UI_Colors["Text"]}}}" valign="center" textemboss="1" text="{{{TextLib::Compose(_("Points limit: %1 | Points to win: %2"), "6", "8")}}}" id="Label_GameInfo" />
		<label posn="{{{158*CW}}} -13.5" sizen="{{{75*SW}}} 5" textsize="2" textcolor="{{{C_UI_Colors["Text"]}}}" halign="right" valign="center" textemboss="1" text="{{{TextLib::Compose(_("Turns won: %1 - %2 | Eliminations: %3 - %4"), "0", "0","0", "0")}}}" id="Label_GoalAverage" />
		<quad posn="{{{163*SW}}} -13.7" sizen="4 4" halign="right" valign="center" image="file://Media/Manialinks/ShootMania/Common/Score.dds" />
	</frame>
</frame>
<script><!--
#Include "TextLib" as TextLib

declare CMlLabel	Label_NameTeam1;
declare CMlLabel 	Label_NameTeam2;
declare CMlFrame	Frame_Ranking;
declare CMlLabel	Label_LongestLaser;
declare CMlLabel	Label_ServerName;
declare CMlLabel	Label_GameInfo;
declare CMlLabel	Label_GoalAverage;

Void UpdatePlayersList(
	Integer				_AttackerKey, 
	Text[Integer]		_Logins, 
	Text[Integer]		_Names, 
	Text[Integer]		_Zones,
	Integer[Integer]	_Ranks,
	Real[Integer]		_LadderPoints,
	Boolean[Integer]	_Ready,
	Integer[Integer]	_DefPoints, 
	Integer[Integer]	_AtkPoints,
	Integer				_Mode,
	Integer[Integer][Integer] _DefHit,
	Integer[Integer]	_Fames,
	Ident[Integer]		_PlayersIds
) {	
	for (I, 1, {{{Players.count}}}) {
		declare Frame_Player	<=> (Frame_Ranking.GetFirstChild("Frame_Player_"^I) as CMlFrame);

		if (_Logins.existskey(I)) {
			declare Quad_NotReady			<=> (Frame_Player.GetFirstChild("Quad_NotReady")			as CMlQuad);
			declare Quad_Ready				<=> (Frame_Player.GetFirstChild("Quad_Ready")				as CMlQuad);
			declare Quad_Avatar 			<=> (Frame_Player.GetFirstChild("Quad_Avatar")				as CMlQuad);
			declare Quad_Eliminated			<=> (Frame_Player.GetFirstChild("Quad_Eliminated")			as CMlQuad);
			declare Label_Name				<=> (Frame_Player.GetFirstChild("Label_Name")				as CMlLabel);
			declare Label_Rank				<=> (Frame_Player.GetFirstChild("Label_Rank")				as CMlLabel);
			declare Frame_Stars				<=> (Frame_Player.GetFirstChild("Frame_Stars")				as CMlFrame);
			declare Label_DefPoints			<=> (Frame_Player.GetFirstChild("Label_DefPoints")			as CMlLabel);
			declare Label_AtkPoints			<=> (Frame_Player.GetFirstChild("Label_AtkPoints")			as CMlLabel);
			declare Quad_Attacker			<=> (Frame_Player.GetFirstChild("Quad_Attacker")			as CMlQuad);
			declare Frame_LadderPoints		<=> (Frame_Player.GetFirstChild("Frame_LadderPoints")		as CMlFrame);
			declare Label_LadderPoints		<=> (Frame_Player.GetFirstChild("Label_LadderPoints")		as CMlLabel);
			declare Frame_DefPointsSimple	<=> (Frame_Player.GetFirstChild("Frame_DefPointsSimple")	as CMlFrame);
			declare Frame_DefPointsDetailed	<=> (Frame_Player.GetFirstChild("Frame_DefPointsDetailed")	as CMlFrame);
			declare Label_DefLaser			<=> (Frame_DefPointsDetailed.GetFirstChild("Label_DefLaser")	as CMlLabel);
			declare Label_DefRocket			<=> (Frame_DefPointsDetailed.GetFirstChild("Label_DefRocket")	as CMlLabel);
			declare Label_DefNucleus		<=> (Frame_DefPointsDetailed.GetFirstChild("Label_DefNucleus")	as CMlLabel);

			declare Side = 1;
			if (Label_Name.PosnX < 0) Side = -1;

			Frame_Player.Show();
			// Ready state
			if (_Mode == {{{C_SequenceWarmUp}}}) {
				Quad_Avatar.PosnX = {{{6 + (3*CW)}}} * Side;
				Label_Name.PosnX = {{{17*CW}}} * Side;
				Label_Rank.PosnX = {{{18*CW}}} * Side;
				Frame_Stars.PosnX = {{{14.6*CW}}} * Side;
				if (_Ready.existskey(I)) {
					if (_Ready[I]) {
						Quad_Ready.Show();
						Quad_NotReady.Hide();
					} else {
						Quad_Ready.Hide();
						Quad_NotReady.Show();
					}
				} else {
					Quad_Ready.Hide();
					Quad_NotReady.Show();
				}
			} else {
				Quad_Avatar.PosnX = {{{6 + (0*CW)}}} * Side;
				Label_Name.PosnX = {{{14*CW}}} * Side;
				Label_Rank.PosnX = {{{15*CW}}} * Side;
				Frame_Stars.PosnX = {{{11.6*CW}}} * Side;
				Quad_Ready.Hide();
				Quad_NotReady.Hide();
			}
			// Avatar
			if (_Logins.existskey(I) && _Names.existskey(I)) {
				Quad_Avatar.ChangeImageUrl("file://Avatars/"^_Logins[I]^"/Default");
			} else {
				Quad_Avatar.ChangeImageUrl("");
			}
			// Status
			/*if (UI.UISequence == CUIConfig::EUISequence::Playing && _PlayersIds.existskey(I)) {
				if (Players.existskey(_PlayersIds[I])) {
					if (Players[_PlayersIds[I]].SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {
						Quad_Eliminated.Show();
					} else {
						Quad_Eliminated.Hide();
					}
				} else {
					Quad_Eliminated.Hide();
				}
			} else {
				Quad_Eliminated.Hide();
			}*/
			// Name
			if (_Names.existskey(I)) {
				Label_Name.SetText("$s"^_Names[I]);
			} else {
				Label_Name.SetText("$s-");
			}
			// Rank
			if (_Ranks.existskey(I) && _Ranks[I] > 0 && _Zones.existskey(I)) {
				Label_Rank.SetText(TextLib::Compose("%1: %2", _Zones[I], TextLib::ToText(_Ranks[I])));
			} else {
				Label_Rank.SetText(TextLib::Compose("%1: %2", _("Other"), "-"));
			}
			// Stars Fames
			if (_Fames.existskey(I)) {
				declare Fame = _Fames[I];
				if (Fame > 0 && Fame <= 5) {
					declare Quad_Star_1 <=> (Frame_Stars.GetFirstChild("Quad_Star_1") as CMlQuad);
					declare Quad_Star_2 <=> (Frame_Stars.GetFirstChild("Quad_Star_2") as CMlQuad);
					declare Quad_Star_3 <=> (Frame_Stars.GetFirstChild("Quad_Star_3") as CMlQuad);
					declare Quad_Star_4 <=> (Frame_Stars.GetFirstChild("Quad_Star_4") as CMlQuad);
					declare Quad_Star_5 <=> (Frame_Stars.GetFirstChild("Quad_Star_5") as CMlQuad);
					Frame_Stars.Show();
					Quad_Star_1.Hide();
					Quad_Star_2.Hide();
					Quad_Star_3.Hide();
					Quad_Star_4.Hide();
					Quad_Star_5.Hide();

					if (Fame >= 1) Quad_Star_1.Show();
					if (Fame >= 2) Quad_Star_2.Show();
					if (Fame >= 3) Quad_Star_3.Show();
					if (Fame >= 4) Quad_Star_4.Show();
					if (Fame >= 5) Quad_Star_5.Show();
				} else {
					Frame_Stars.Hide();
				}
			} else {
				Frame_Stars.Hide();
			}
			// Ladder points
			if (_Mode == {{{C_SequencePodium}}} && _LadderPoints.existskey(I) && _LadderPoints[I] >= 0) {
				declare LadderPointsExplode = TextLib::Split(".", TextLib::ToText(_LadderPoints[I]));
				declare LadderPoints = "0.0";
				if (LadderPointsExplode.existskey(0)) LadderPoints = LadderPointsExplode[0];
				if (LadderPointsExplode.existskey(1)) LadderPoints ^= "."^TextLib::SubString(LadderPointsExplode[1], 0, 2);

				Frame_LadderPoints.Show();
				Label_LadderPoints.SetText("$s$bb8+"^LadderPoints);
			} else {
				Frame_LadderPoints.Hide();
			}
			// DefPoints
			/*
			if (_DefHit.existskey(I) && _DefHit[I][1] >= 0 && _DefHit[I][3] >= 0) {
				Frame_DefPointsSimple.Hide();
				Frame_DefPointsDetailed.Show();
				if (_DefPoints.existskey(I)) {
					Label_DefLaser.SetText("$s"^_DefHit[I][1]);
					Label_DefRocket.SetText("$s"^_DefHit[I][2]);
					Label_DefNucleus.SetText("$s"^_DefHit[I][3]);
				} else {
					Label_DefLaser.SetText("$s0");
					Label_DefRocket.SetText("$s0");
					Label_DefNucleus.SetText("$s0");
				}
			} else {*/
				Frame_DefPointsSimple.Show();
				Frame_DefPointsDetailed.Hide();
				if (_DefPoints.existskey(I)) {
					Label_DefPoints.SetText("$s"^_DefPoints[I]);
				} else {
					Label_DefPoints.SetText("$s0");
				}
			//}
			// AtkPoints
			if (_AtkPoints.existskey(I)) {
				Label_AtkPoints.SetText("$s"^_AtkPoints[I]);
			} else {
				Label_AtkPoints.SetText("$s0");
			}
			// Attacker
			if (I == _AttackerKey && _Mode == {{{C_SequencePlaying}}}) {
				Quad_Attacker.Show();
			} else {
				Quad_Attacker.Hide();
			}
		} else {
			Frame_Player.Hide();
		}
	}
}

Void UpdateStats(
	Text[Integer]		_Names,
	Real[Integer]		_LaserLongest,
	Integer[Integer]	_LaserHit,
	Integer[Integer]	_LaserShot
) {	
	declare LaserLongest = Real[Integer];
	foreach (Key => Distance in _LaserLongest) {
		if (Distance > 0.) LaserLongest[Key] = Distance * -1.;
	}
	LaserLongest = LaserLongest.sort();
	declare LaserAccuracy = Real[Integer];

	foreach (Key => Nb in _LaserShot) {
		if (Nb > 0 && _LaserHit.existskey(Key) && _LaserHit[Key] > 0) {
			LaserAccuracy[Key] = ((_LaserHit[Key] * 1.) / (Nb * 1.)) * -100.;
		}
	}
	LaserAccuracy = LaserAccuracy.sort();

	declare Longest = "-";
	declare LongestName = "-";
	declare Accuracy = "-";
	declare AccuracyName = "-";

	foreach (Key => Distance in LaserLongest) {
		Longest = TextLib::SubString(TextLib::ToText(Distance*-1.), 0, 5)^"m";
		if (_Names.existskey(Key)) LongestName = "$<"^_Names[Key]^"$>";
		break;
	}

	foreach (Key => Percentage in LaserAccuracy) {
		Accuracy = _LaserHit[Key]^"/"^_LaserShot[Key]^" ("^TextLib::SubString(TextLib::ToText(Percentage*-1.), 0, 5)^"%)";
		if (_Names.existskey(Key)) AccuracyName = _Names[Key];
		break;
	}

	Label_LongestLaser.SetText(TextLib::Compose(_("Longest Laser: %1 by %2"), Longest, LongestName));
}

Void UpdateGameInfo(
	Integer _PointsLimit,
	Integer _PointsToWin,
	Integer[Integer] _Turns,
	Integer[Integer] _Eliminations
) {
	Label_GameInfo.SetText(TextLib::Compose(_("Points limit: %1 | Points to win: %2"), TextLib::ToText(_PointsLimit), TextLib::ToText(_PointsToWin)));

	if (_Eliminations.existskey(1) && _Eliminations.existskey(2)) {
		Label_GoalAverage.SetText(TextLib::Compose(_("Turns won: %1 - %2 | Eliminations: %3 - %4"), TextLib::ToText(_Turns[1]), TextLib::ToText(_Turns[2]), TextLib::ToText(_Eliminations[1]), TextLib::ToText(_Eliminations[2])));
	} else {
		Label_GoalAverage.SetText(TextLib::Compose(_("Turns won: %1 - %2"), TextLib::ToText(_Turns[1]), TextLib::ToText(_Turns[2])));
	}
}

Void UpdatePlayersStatus(Boolean _Forced) {
	declare netread Text[Integer] Net_LayerST_Logins for UI;

	foreach (Player in Players) {
		declare PrevSpawnStatus for Player = CSmPlayer::ESpawnStatus::Spawned;
		if (PrevSpawnStatus != Player.SpawnStatus || _Forced) {
			PrevSpawnStatus = Player.SpawnStatus;
			if (!Net_LayerST_Logins.exists(Player.Login)) continue;

			declare Frame_Player <=> (Frame_Ranking.GetFirstChild("Frame_Player_"^Net_LayerST_Logins.keyof(Player.Login)) as CMlFrame);
			if (Frame_Player == Null) continue;

			declare Quad_Eliminated <=> (Frame_Player.GetFirstChild("Quad_Eliminated") as CMlQuad);
			declare netread Integer Net_LayerST_Mode for UI;

			if (Net_LayerST_Mode == {{{C_SequencePlaying}}} && UI.UISequence == CUIConfig::EUISequence::Playing) {
				if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {
					Quad_Eliminated.Show();
				} else {
					Quad_Eliminated.Hide();
				}
			} else {
				Quad_Eliminated.Hide();
			}
		}
	}
}

main() {
	Label_NameTeam1			<=> (Page.GetFirstChild("Label_NameTeam1")		as CMlLabel);
	Label_NameTeam2			<=> (Page.GetFirstChild("Label_NameTeam2")		as CMlLabel);
	Frame_Ranking			<=> (Page.GetFirstChild("Frame_Ranking")		as CMlFrame);
	Label_LongestLaser		<=> (Page.GetFirstChild("Label_LongestLaser")	as CMlLabel);
	Label_ServerName		<=> (Page.GetFirstChild("Label_ServerName")		as CMlLabel);
	Label_GameInfo			<=> (Page.GetFirstChild("Label_GameInfo")		as CMlLabel);
	Label_GoalAverage		<=> (Page.GetFirstChild("Label_GoalAverage")	as CMlLabel);

	declare netread Integer				Net_LayerST_Update			for UI;
	declare netread Integer				Net_LayerST_AttackerKey		for UI;
	declare netread Text[Integer]		Net_LayerST_Logins			for UI;
	declare netread Integer[Integer]	Net_LayerST_AtkPoints		for UI;
	declare netread Integer[Integer]	Net_LayerST_DefPoints		for UI;
	declare netread Real[Integer]		Net_LayerST_LaserLongest	for UI;
	declare netread Integer[Integer]	Net_LayerST_LaserShot		for UI;
	declare netread	Integer[Integer]	Net_LayerST_LaserHit		for UI;
	declare netread Integer				Net_LayerST_PointsLimit		for UI;
	declare netread Integer				Net_LayerST_PointsToWin		for UI;
	declare netread Integer[Integer]	Net_LayerST_Turns			for UI;
	declare netread Integer[Integer]	Net_LayerST_Eliminations	for UI;
	declare netread Boolean[Integer]	Net_LayerST_Ready			for UI;
	declare netread Integer				Net_LayerST_Mode			for UI;
	declare netread Integer[Integer][Integer] Net_LayerST_DefHit	for UI;

	declare Text[Integer]		Logins;
	declare Text[Integer]		Names;
	declare Integer[Integer]	LadderRanks;
	declare Text[Integer]		Zones;
	declare Integer				Order;
	declare Real[Integer]		LadderPoints;
	declare Integer[Integer]	Fames;
	declare Ident[Integer]		PlayersIds;

	declare LastUpdate = Net_LayerST_Update;
	declare PrevUISequence = CUIConfig::EUISequence::None;
	declare PrevServerName = "";

	while (True) {
		yield;

		if (InputPlayer == Null) continue;
		if (!PageIsVisible) continue;

		if (PrevServerName != CurrentServerName) {
			PrevServerName = CurrentServerName;
			Label_ServerName.SetText(TextLib::Compose("%1: $<%2$>", _("Server"), CurrentServerName));
		}

		if (LastUpdate != Net_LayerST_Update) {
			LastUpdate = Net_LayerST_Update;

			UpdatePlayersStatus(True);

			if (Teams[0].ColorizedName == "$<$00fBlue$>") Label_NameTeam1.SetText("$<$fffBlue$>");
			else Label_NameTeam1.SetText(Teams[0].ColorizedName);
			if (Teams[1].ColorizedName == "$<$f00Red$>") Label_NameTeam2.SetText("$<$fffRed$>");
			else Label_NameTeam2.SetText(Teams[1].ColorizedName);

			Logins = Net_LayerST_Logins;

			if (Net_LayerST_AttackerKey <= 0) Order = -1;
			else if (Net_LayerST_AttackerKey <= 3) Order = Net_LayerST_AttackerKey;
			else Order = Net_LayerST_AttackerKey - 3;

			Names.clear();
			LadderRanks.clear();
			foreach (Score in Scores) {
				if (Logins.exists(Score.User.Login)) {
					declare Key = Logins.keyof(Score.User.Login);
					Names[Key] = Score.User.Name;
					LadderRanks[Key] = Score.User.LadderRank;
					LadderPoints[Key] = Score.LadderScore;
					Fames[Key] = Score.User.FameStars;

					declare ZonePath = "";
					if (Score.User.ZonePath != "") {
						declare ExplodeZonePath = TextLib::Split("|", Score.User.ZonePath);
						if (ExplodeZonePath.existskey(1)) ZonePath = ExplodeZonePath[1];
					}
					Zones[Key] = ZonePath;
				}
			}
			/*foreach (Player in Players) {
				if (Logins.exists(Player.Login)) {
					declare Key = Logins.keyof(Player.Login);
					PlayersIds[Key] = Player.Id;
				}
			}*/

			UpdatePlayersList(
				Net_LayerST_AttackerKey, 
				Logins, 
				Names, 
				Zones,
				LadderRanks,
				LadderPoints,
				Net_LayerST_Ready, 
				Net_LayerST_DefPoints, 
				Net_LayerST_AtkPoints,
				Net_LayerST_Mode,
				Net_LayerST_DefHit,
				Fames,
				PlayersIds
			);

			UpdateStats(
				Names,
				Net_LayerST_LaserLongest,
				Net_LayerST_LaserHit,
				Net_LayerST_LaserShot
			);

			UpdateGameInfo(
				Net_LayerST_PointsLimit,
				Net_LayerST_PointsToWin,
				Net_LayerST_Turns,
				Net_LayerST_Eliminations
			);
		}

		if (PrevUISequence != UI.UISequence) {
			PrevUISequence = UI.UISequence;

			if (UI.UISequence != CUIConfig::EUISequence::Playing) {
				for (I, 1, {{{Players.count}}}) {
					declare Frame_Player	<=> (Frame_Ranking.GetFirstChild("Frame_Player_"^I)	as CMlFrame);
					declare Quad_Eliminated <=> (Frame_Player.GetFirstChild("Quad_Eliminated") as CMlQuad);
					Quad_Eliminated.Hide();
				}
			}
		}

		if (UI.UISequence == CUIConfig::EUISequence::Playing) UpdatePlayersStatus(False);
	}
}
--></script>
""";
//In dev
//return "";
return ManiaLink;
}
/** Update the score table manialink string.
 *
 *	@param	_Mode	Type of display for the scores table (warm-up, playing, ...)
 * 
 *	@return		The manialink string
 */
Void UpdateLayerScoresTable(Integer _Mode) {
declare Logins			= Text[Integer];
declare Attacker1Key		= -1;
declare Attacker2Key		= -1;
declare AtkPoints		= Integer[Integer];
declare DefPoints		= Integer[Integer];
declare LasersLongest	= Real[Integer];
declare LasersHit		= Integer[Integer];
declare LasersShot		= Integer[Integer];
declare Eliminations	= [0 => 0];
declare ReadyState		= Boolean[Integer];
//declare DetailedDefPoints = Integer[Integer][Integer];

for (I, 1, 2) {
	declare J = 1;
	foreach (Id => Order in G_MapOrder[I]) {
		if (Players.existskey(Id)) {
			declare Key = J+((I-1)*G_MapOrder[1].count);
			//Key=Order;
			declare Player <=> Players[Id];
			Logins[Key] = Player.Login;
			if (Id == G_Team1AttackingPlayer) Attacker1Key = Key;
			if (Id == G_Team2AttackingPlayer) Attacker2Key = Key;
			if (Player.Score != Null) {
				//declare Integer NbHit for Player.Score;
				declare Real LaserLongest for Player.Score =0.;
				//declare Integer LaserHit for Player.Score =0;
				//declare Integer LaserShot for Player.Score =0;
				declare Integer WonAttackRounds for Player.Score =0;//Searchme
				//G_InitDefHit = [1 => 0, 2 => 0, 3 => 0];
				//declare DefHit for Player.Score = G_InitDefHit;
				
				AtkPoints[Key] = WonAttackRounds;
				/*
				if(G_AttackPoints.existskey(Id)) AtkPoints[Key] = G_AttackPoints[Id];
				*/
				foreach(Score in Scores){
					if(Score==Player.Score){
						DefPoints[Key]=Score.Points;
					}
				}
				if(Scores.existskey(Id)) DefPoints[Key] = Scores[Id].Points;
				LasersLongest[Key] = LaserLongest;
				//LasersHit[Key] = LaserHit;
				//LasersShot[Key] = LaserShot;
				//DetailedDefPoints[Key] = DefHit;
			}
			
			ReadyState[Key] = WarmUp::IsReady(Player);
		}
		J += 1;
	}
}

//if (G_TieBreak) Eliminations = [1 => G_TieBreakDefElim[1], 2 => G_TieBreakDefElim[2]];

declare PlayersAndSpectators = CSmPlayer[];
foreach (Player in Players) PlayersAndSpectators.add(Player);
foreach (Spectator in Spectators) PlayersAndSpectators.add(Spectator);
foreach (Player in PlayersAndSpectators) {
	declare UI <=> UIManager.GetUI(Player);
	if (UI == Null) continue;

	declare netwrite Integer			Net_LayerST_Update			for UI;
	declare netwrite Integer			Net_LayerST_Attacker1Key	for UI;
	declare netwrite Integer			Net_LayerST_Attacker2Key	for UI;
	declare netwrite Text[Integer]		Net_LayerST_Logins			for UI;
	declare netwrite Integer[Integer]	Net_LayerST_AtkPoints		for UI;
	declare netwrite Integer[Integer]	Net_LayerST_DefPoints		for UI;
	declare netwrite Real[Integer]		Net_LayerST_LaserLongest	for UI;
	declare netwrite Integer[Integer]	Net_LayerST_LaserShot		for UI;
	declare netwrite Integer[Integer]	Net_LayerST_LaserHit		for UI;
	declare netwrite Integer			Net_LayerST_PointsLimit		for UI;
	declare netwrite Integer			Net_LayerST_PointsToWin		for UI;
	declare netwrite Integer[Integer]	Net_LayerST_Turns			for UI;
	declare netwrite Integer[Integer]	Net_LayerST_Eliminations	for UI;
	declare netwrite Boolean[Integer]	Net_LayerST_Ready			for UI;
	declare netwrite Integer			Net_LayerST_Mode			for UI;
	declare netwrite Integer[Integer][Integer] Net_LayerST_DefHit	for UI;

	Net_LayerST_Update			= Now;
	Net_LayerST_Attacker1Key	= Attacker1Key;
	Net_LayerST_Attacker2Key	= Attacker2Key;
	Net_LayerST_Logins			= Logins;
	Net_LayerST_AtkPoints		= AtkPoints;
	Net_LayerST_DefPoints		= DefPoints;
	Net_LayerST_LaserLongest	= LasersLongest;
	Net_LayerST_LaserShot		= LasersShot;
	Net_LayerST_LaserHit		= LasersHit;
	Net_LayerST_PointsLimit		= S_PointLimitDecisiveRound;
	Net_LayerST_PointsToWin		= S_PointLimitToWin;
	Net_LayerST_Turns			= [1 => G_RoundScores[1], 2 => G_RoundScores[2]];
	Net_LayerST_Eliminations	= Eliminations;
	Net_LayerST_Ready			= ReadyState;
	Net_LayerST_Mode			= _Mode;
	//Net_LayerST_DefHit			= DetailedDefPoints;
}
}
// Spawn a Player
Void SpawnThePlayer(CSmPlayer Player){
	declare CSmBlockSpawn Spawn;
	foreach(BlockSpawn in BlockSpawns){
		if(BlockSpawn.Base.Clan==Player.CurrentClan){
			Spawn = BlockSpawn;
		}
	}
	
	This.SetPlayerAmmoMax(Player, CSmMode::EWeapon::Nucleus, 1);
	This.SetPlayerAmmoMax(Player, CSmMode::EWeapon::Laser, 1);
	This.SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, 4);
	This.SetPlayerAmmoMax(Player, CSmMode::EWeapon::Arrow, 1);
	
	if (Player.Id == G_Team1AttackingPlayer || Player.Id == G_Team2AttackingPlayer){
		This.SetPlayerWeapon(Player, CSmMode::EWeapon::Laser, False);
		Player.AmmoGain = C_AttackerAmmoGain;
		if(Player.Id == G_Team1AttackingPlayer){
			Player.ArmorMax = G_Team2DefenderPlayers.count*C_AttackerArmorMultiplier*100;
		}else{
			Player.ArmorMax = G_Team1DefenderPlayers.count*C_AttackerArmorMultiplier*100;
		}
		declare UI <=> UIManager.GetUI(Player);
		if (UI != Null) {
			UI.SpectatorForcedClan = Player.CurrentClan;
		}
		
		SM::SpawnPlayer(Player, Player.CurrentClan, Spawn, StartTime);
		//SpawnPlayer(Player, Player.CurrentClan, Player.ArmorMax, Spawn, StartTime);
		return;
	}else{
		This.SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, True);
		Player.AmmoGain = C_DefenderAmmoGain;
		Player.ArmorMax = C_DefenderArmor*100;
		Player.StaminaMax = 1. * C_DefStaminaMaxMultiplier;
		Player.StaminaGain = 1. * C_DefStaminaMaxMultiplier;
		
		declare UI <=> UIManager.GetUI(Player);
		if (UI != Null) {
			UI.SpectatorForcedClan = Player.CurrentClan;
		}
		
		SM::SpawnPlayer(Player, Player.CurrentClan, Spawn, StartTime);
		//SpawnPlayer(Player, Player.CurrentClan, Player.ArmorMax, Spawn, StartTime);
		return;
	}
}
/** Spawns all the players.
 * 
 * @param _Phase		0 playing time, 1 warmup KotM, 2 warmup classic/free, 3 waiting time 
 */
Void SpawnThemAll(Integer _Phase) {
	// Get spawns
	declare CSmBlockSpawn BlockSpawn1;
	declare CSmBlockSpawn BlockSpawn2;
	foreach (Spawn in BlockSpawns) {
		if(Spawn.Order==1){
			BlockSpawn1 = Spawn;
		}else if(Spawn.Order==2){
			BlockSpawn2 = Spawn;
		}
	}
	

	// WarmUp classic/free || Waiting time
	if (_Phase == 2 || _Phase == 3) {
		foreach (Player in Players) {
			declare WarmUpSide for Player = True;
			if (Player.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) continue;

			SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, 4);
			SetPlayerAmmoMax(Player, CSmMode::EWeapon::Laser, 1);
			SetPlayerAmmoMax(Player, CSmMode::EWeapon::Nucleus, 1);
			SetPlayerAmmoMax(Player, CSmMode::EWeapon::Arrow, 1);
			
			//Player.ArmorMax	= 2;
			if (WarmUpSide) {
				Player.AmmoGain	= 1. * C_AttackerAmmoGain;
				Player.StaminaMax = 1.;
				Player.StaminaGain = 1.;
				Player.ArmorMax = 200;
				Player.Armor = Player.ArmorMax;
				SetPlayerWeapon(Player, CSmMode::EWeapon::Laser, False);
				SM::SpawnPlayer(Player, Player.RequestedClan, BlockSpawn1, Now);
			} else {
				Player.AmmoGain	= 1. * C_DefenderAmmoGain;
				Player.StaminaMax = 1. * C_DefStaminaMaxMultiplier;
				Player.StaminaGain = 1. * C_DefStaminaMaxMultiplier;
				Player.ArmorMax = 200;
				Player.Armor = Player.ArmorMax;
				SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, True); 
				SM::SpawnPlayer(Player, Player.RequestedClan, BlockSpawn2, Now);
			}
			Player.IsHighlighted = True;
			WarmUpSide = !WarmUpSide;
		}
	}
	// Playing time
	else {
		foreach(Player in Players){
			SpawnThePlayer(Player);
		}
	} 	
}
/** Can we start the turn or not?
 *
 * @param _MinimumCriteria	True: At least 1 def and 1 atk ready | False: all players with 1 atk and 1 def ready
 *
 * @return		True if we can start the turn, false otherwise
 */
Integer CanStartTurn(Boolean _MinimumCriteria) {
	declare NbAtk = 0;
	declare NbAtkReady = 0;
	declare NbDef = 0;
	declare NbDefReady = 0;
	declare CanStart = False;

	// Can't start round if ...
	foreach (ClanNumber => ClanOrder in WarmUp::GetOrder()) {
		// ... a slot is empty
		if (!G_FreeMode  && ClanOrder.count != C_PlayerNeeded/2) {
			return -1;
		} else if (G_FreeMode && ClanOrder.count < 2) {
			return -3;
		}
		foreach (PlayerId => PlayerOrder in ClanOrder) {
			// ... the player in the slot doesn't exist
			if (!Players.existskey(PlayerId)) {
				return -2;
			}
			// ... the player in the slot changed team
			else if (Players[PlayerId].RequestedClan != ClanNumber) {
				return -7;
			}
			// In other cases, check if the player is ready
			else {
				declare IsPlayerReady = False;
				declare Player <=> Players[PlayerId];

				// Bot default to ready state
				if (Player.IsFakePlayer) {
					IsPlayerReady = True;
				} else {
					IsPlayerReady = WarmUp::IsReady(Player);
				}
				declare Clan = 0;
				Clan = Player.RequestedClan;
				if (Clan == 1) {
					if (IsPlayerReady) NbAtkReady += 1;
					NbAtk += 1;
				} else if (Clan == 2) {
					if (IsPlayerReady) NbDefReady += 1;
					NbDef += 1;
				}
			}
		}
	}

	// If we don't want to use the warmup, return true when there's at least one player in each clan
	if (S_WarmUpDuration <= 0) {
		return 1;
	} else if (_MinimumCriteria) {
		if ((NbAtkReady >= 1) && (NbDefReady >= 1)) return 1;
		else return -4;
	} else {
		if (G_FreeMode) {
			if((NbAtkReady == NbAtk) && (NbDefReady == NbDef)) return 1;
			else return -5;
		} else {
			if((NbAtkReady >= C_PlayerNeeded/2) && (NbDefReady >= C_PlayerNeeded/2)) return 1;
			else return -5;
		}
	}

	return -6;
}
//Check if settings changed
Void CheckSettings(Boolean restart){
	if (G_FreeMode!=S_FreeMode){
		
		if(restart){
			UIManager.UIAll.SendChat("$f90Change mode and start a new map");
			sleep(1000);
			MatchEndRequested = True;
		}else if(!G_RestartNeeded){
			G_RestartNeeded=True;
			UIManager.UIAll.SendChat("$f90Need to restart to apply Settings");
		}
	}
	if(G_UseLaserVsBullets!=S_UseLaserVsBullets){
		if(restart){
			UIManager.UIAll.SendChat("$f90Change Settings and start a new map");
			sleep(1000);
			MatchEndRequested = True;
		}else if(!G_RestartNeeded){
			G_RestartNeeded=True;
			UIManager.UIAll.SendChat("$f90Need to restart to apply Settings");
		}
	}
}
// ---------------------------------- //
/// Warmup.
Void DoWarmUp() {
	// Waiting that the UI receives initial data
	//UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedHidden;
	MB_Sleep(1000);
	
	if (MB_UseScriptCallbacks) XmlRpc.SendCallback("BeginWarmup", Json::Enfold(Json::Stringify("AllReady", False)));

	declare RazorTime = -1;
	StartTime = Now + 1000;
	EndTime = -1;
	UIManager.UIAll.CountdownEndTime = EndTime;
	SM::UnspawnAllPlayers();
	if(!S_GetAPointForDefense){
		SpawnScreen::CreateRules("Legends", Description, False);
	}else{
		SpawnScreen::CreateRules("Legends", DescriptionWithDefensePoints, False);
	}

	// Shutdown the poles during warmup
	/*
	foreach (Goal in BlockPoles) {
		Goal.Gauge.Clan = 0;
		Goal.Gauge.Speed = 0;
		Goal.Gauge.Value = 0;
		Goal.Gauge.Max = 1000;
		Goal.Captured = False;
	}*/

	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::PhaseChange;
	UIManager.UIAll.BigMessageSoundVariant = 0;
	UIManager.UIAll.BigMessage = TextLib::Compose("$f90%1", _("Warm-up"));
	UIManager.UIAll.StatusMessage = _("Press F6 once you're ready.");
	
	// Param: Duration, UseTeam, UseOrder, NumberOfPlayers
	if(G_FreeMode){
		WarmUp::Before(S_WarmUpDuration, True, True, C_MaxPlayers/2);
		
	}else{
		WarmUp::Before(S_WarmUpDuration, True, True, C_PlayerNeeded/2);
	}
	
	
	//LayerScores.ManialinkPage = CreateLayerScoresTableElite();

	while ((EndTime == -1 || Now <= EndTime) && !ServerShutdownRequested && !MatchEndRequested) {
		yield;
		// Let the server sleep if there's no players on it
		if (PlayersNbTotal <= 0) continue;
		/*
		foreach (Event in PendingEvents) {
			if (Event.Type == CSmModeEvent::EType::OnHit && Event.Victim != Null && Event.WeaponNum == C_WeaponLaser) {
				DisplayHitDistance(Event.Shooter, Event.Victim, True);
			}
		}*/
		//Settingscheck
		CheckSettings(True);
		SpawnThemAll(2);
		
		SM::UnspawnPlayersChangingClan();
		WarmUp::Loop();
		XmlRpc::Loop();
		if (WarmUp::OrderHasChanged() || WarmUp::ReadyHasChanged()) {
			G_MapOrder = WarmUp::GetOrder();
			
			LayerScores.ManialinkPage = CreateLayerScoresTableElite();
			UpdateLayerScoresTable(C_SequenceWarmUp);
			
		}

		//UpdateSpectators();
		// ---------------------------------- //
		// Update the players clublinks
		/*if (S_ForceClublinkTeam1 == "" && S_ForceClublinkTeam2 == "") {
			Clublink::DefineTeamAuto();
			Clublink::Update();
		}*/

		{
			// Warmup ending conditions
			declare SomePlayersReady = CanStartTurn(True);
			declare AllPlayersReady = CanStartTurn(False);

			if (AllPlayersReady == 1 || WarmUp::EndRequested()) {
				if (EndTime == -1 && S_WarmUpDuration <= 0) EndTime = Now;
				else if (EndTime == -1 || EndTime > Now + 5000) EndTime = Now + 5 * 1000;
			} else if (SomePlayersReady == 1) {
				if (RazorTime == -1) RazorTime = Now + S_WarmUpDuration*1000;
				EndTime = RazorTime;
			} else {
				RazorTime = -1;
				EndTime = -1;
			}
		}
	}
	
	WarmUp::After();
	
	
	StartTime = -1;
	EndTime = -1;

	if (MB_UseScriptCallbacks) XmlRpc.SendCallback("EndWarmup", Json::Enfold(Json::Stringify("AllReady", True)));

	//PlaySound(CUIConfig::EUISound::StartMatch, 0);
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
	UIManager.UIAll.StatusMessage = "";
	UIManager.UIAll.BigMessage = "";
	SM::UnspawnAllPlayers();
	// ---------------------------------- //
	// Update the players clublinks
	//if (S_ForceClublinkTeam1 == "" && S_ForceClublinkTeam2 == "") Clublink::DefineTeamAuto();
	//else Clublink::DefineTeamFromUrl(S_ForceClublinkTeam1, S_ForceClublinkTeam2);
	//Clublink::SyncUpdate();

	//declare LayerUpdated = Layers::Update("ScoresTable", CreateLayerScoresTable());

	// ---------------------------------- //
	// Play team presentation
	
	MB_PlayersPresentationSequence();
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
	G_MapOrder = WarmUp::GetOrder();
}


// Update the score summary header.
Void UpdateHeader() {
	declare CSmPlayer Player1 <=> Null;
	declare CSmPlayer Player2 <=> Null;
	declare HeaderClanScores = Integer[Integer];

	HeaderClanScores = [1 => G_MapScores[1], 2 => G_MapScores[2]];

	// Find a captain for each clan
	foreach (Player in Players) {
		if (Player.CurrentClan == 1) {
			Player1 <=> Player;
		} else if (Player.CurrentClan == 2) {
			Player2 <=> Player;
		}
	}

	UIManager.UIAll.OverlayScoreSummary = True;
	if (Player1 != Null) {
		UIManager.UIAll.ScoreSummary_Player1 = Player1.Id;
		UIManager.UIAll.ScoreSummary_Points1 = G_RoundScores[1];
		UIManager.UIAll.ScoreSummary_MatchPoints1 = HeaderClanScores[1];
	} else {
		UIManager.UIAll.ScoreSummary_Player1 = NullId;
		UIManager.UIAll.ScoreSummary_Points1 = 0;
		UIManager.UIAll.ScoreSummary_MatchPoints1 = 0;
	}

	if (Player2 != Null) {
		UIManager.UIAll.ScoreSummary_Player2 = Player2.Id;
		UIManager.UIAll.ScoreSummary_Points2 = G_RoundScores[2];
		UIManager.UIAll.ScoreSummary_MatchPoints2 = HeaderClanScores[2];
	} else {
		UIManager.UIAll.ScoreSummary_Player2 = NullId;
		UIManager.UIAll.ScoreSummary_Points2 = 0;
		UIManager.UIAll.ScoreSummary_MatchPoints2 = 0;
	}
}


// Update the Hud3dMarkers.
/*
Void UpdateMarkers(CSmPlayer Player) {
	// Set the marker above the goals
	foreach (Goal in BlockPoles) {
		declare Name = "";
		declare Type = "";
		declare PosX = Goal.Position.X;
		declare PosY = Goal.Position.Y + 25;
		declare PosZ = Goal.Position.Z;
		declare Set = False;
		if(!Set){
			foreach(PlayerId in G_Team1DefenderPlayers){
				if(Player.Id == PlayerId){
					Set=True;
					if (Goal.Order == 1) {
						Name = "$wDefend";
					} else if (Goal.Order == 2) {
						Name = "";
					}
				}
			}
		}if(!Set){
			foreach(PlayerId in G_Team2DefenderPlayers){
				if(Player.Id == PlayerId){
					Set=True;
					if (Goal.Order == 2) {
						Name = "$wDefend";
					} else if (Goal.Order == 1) {
						Name = "";
					}
				}
			}
		}if(!Set){
			if(Player.Id == G_Team1AttackingPlayer){
				Set=True;
				
				if (Goal.Order == 2) {
					Name = "$wAttack";
				} else if (Goal.Order == 1) {
					Name = "";
				}
			}
		}if(!Set){
			if(Player.Id == G_Team2AttackingPlayer){
				Set=True;
				if (Goal.Order == 1) {
					Name = "$wAttack";
				} else if (Goal.Order == 2) {
					Name = "";
				}
			}
		}
		

		if (Name == "") continue;
		
		declare marker <=> UIManager.UILayerCreate();
		marker.Type = CUILayer::EUILayerType::Markers;

		marker.ManialinkPage ^= """
			<marker {{{Name}}} pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" />
		""";
		UIManager.GetUI(Player).UILayers.add(marker);
	}
}*/
/** Helper for the DisplayHitFunction
 *
 * @param	_Player		The player who'll receive the notice
 * @param	_Message	The message for the notice
 */
Void NoticeHitDistance(CSmPlayer _Player, Text _Message) {
	declare UI <=> UIManager.GetUI(_Player);
	if (UI != Null) {
		UI.SendNotice(
			_Message, CUIConfig::ENoticeLevel::MatchInfo, 
			Null, CUIConfig::EAvatarVariant::Default, 
			CUIConfig::EUISound::Silence, 0
		);
	}
}
/** Display the distance between the shooter and the victim
 *
 *	@param	_Shooter		The shooter
 *	@param	_Victim			The Victim
 *	@param	_ShooterOnly	Display the distance hit message to the shooter only
 */
Void DisplayHitDistance(CSmPlayer _Shooter, CSmPlayer _Victim, Boolean _ShooterOnly) {
	if (_Shooter == Null || _Victim == Null) return;
	//declare LongestRailDistance for _Shooter.Score = 0.;
	declare Distance = MathLib::Distance(_Shooter.Position, _Victim.Position);
	Distance = MathLib::NearestInteger(Distance*10.0)/10.0;
	declare DistanceMessage = TextLib::Compose(_("%1m hit!"), TextLib::SubString(TextLib::ToText(Distance), 0, 5));
	if (_ShooterOnly) {
		NoticeHitDistance(_Shooter, DistanceMessage);
	} else {
		NoticeHitDistance(_Shooter, DistanceMessage);
		foreach (Spectator in Spectators) {
			NoticeHitDistance(Spectator, DistanceMessage);
		}/*
		if (Distance > LongestRailDistance) {
			G_LongestRailName = _Shooter.Name;
			G_LongestRailDistance = Distance;
		}*/
	}
}
// Create markers layer manialink
Text GetMarkersLayerManialink(CSmBlockPole Pole, Text Name) {
	declare Type = """label="{{{Name}}}" """;
	declare PosX = Pole.Position.X;
	declare PosY = Pole.Position.Y + 25;
	declare PosZ = Pole.Position.Z;
	declare Set = False;
	
	declare Manialink = "";
		Manialink ^= """<marker {{{Type}}} pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" />""";
	return Manialink;
}

//
Void InitialMarkers(Integer Clan){
	foreach(Pole in BlockPoles){
		if(Pole.Gauge.Clan == 2 ){
			if(Clan == 0 || Clan == 1){
			foreach(PlayerId in G_Team1DefenderPlayers){
				UIManager.GetUI(Players[PlayerId]).Hud3dMarkers = GetMarkersLayerManialink(Pole, "Defend");
				}
			}
			if(Clan == 0 || Clan == 2){
			UIManager.GetUI(Players[G_Team2AttackingPlayer]).Hud3dMarkers = GetMarkersLayerManialink(Pole, "Attack");
			}
		}else if(Pole.Gauge.Clan == 1){
			if(Clan == 0 || Clan == 2){
			foreach(PlayerId in G_Team2DefenderPlayers){
				UIManager.GetUI(Players[PlayerId]).Hud3dMarkers = GetMarkersLayerManialink(Pole, "Defend");
			}
			}
			if(Clan == 0 || Clan == 1){
			UIManager.GetUI(Players[G_Team1AttackingPlayer]).Hud3dMarkers = GetMarkersLayerManialink(Pole, "Attack");
			}
		}
	}
}
// Increases score points
Void IncreaseAtkPoints(Ident _Id, Integer _Points) {
log(_Id^" won "^_Points);
	if (Players.existskey(_Id) && Players[_Id].Score != Null) {
	declare Integer WonAttackRounds for Players[_Id].Score;
	WonAttackRounds = WonAttackRounds + _Points;
	/*
		if(_Points >=0){
			if(G_AttackPoints.existskey(_Id)) G_AttackPoints[_Id]+=_Points;
			else G_AttackPoints[_Id]=_Points;
		}else{
			Players[_Id].Score.Points -= -1*_Points;
		}
		*/
	}
}
/*
//Create Marker Layer for Attacker
Text GetMarkerForAttacker(CSmPlayer Player){
	return """<frame id="Marker_{{{TextLib::MLEncode(Player.Login)}}}"><quad sizen="4 4" halign="center" valign="bottom" image="file://Media/Manialinks/ShootMania/Common/LaserWhite.dds" /></frame>""";
}*/
//Winnings
Void Team1WonAttack(){
	IncreaseAtkPoints(Players[G_Team1AttackingPlayer].Id, 1);
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::Capture;
	UIManager.UIAll.BigMessageSoundVariant = 0;
	UIManager.UIAll.StatusMessage = TextLib::Compose("$<%1$> %2",Players[G_Team1AttackingPlayer].Name, _("wins the Attack"));
	UIManager.UIAll.SendNotice(
		UIManager.UIAll.StatusMessage,
		CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
		CUIConfig::EUISound::Silence, 0);
	G_LastStatusMessage=Now;
	G_Team1WonAttack=True;
	G_Team2WonDefense=False;
	foreach (Pole in BlockPoles){
		if(Pole.Gauge.Clan == 1){
			Pole.Gauge.ValueReal = 1.0;
		}
	}
	G_Pole1Captured = True;
	G_RoundScores[1]+=1;
	UpdateHeader();
	//Unspawn Player
	UnspawnPlayer(Players[G_Team1AttackingPlayer]);
	
}
Void Team2WonAttack(){
	IncreaseAtkPoints(Players[G_Team2AttackingPlayer].Id, 1);
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::Capture;
	UIManager.UIAll.BigMessageSoundVariant = 0;
	UIManager.UIAll.StatusMessage = TextLib::Compose("$<%1$> %2",Players[G_Team2AttackingPlayer].Name, _("wins the Attack"));
	UIManager.UIAll.SendNotice(
		UIManager.UIAll.StatusMessage,
		CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
		CUIConfig::EUISound::Silence, 0);
	G_LastStatusMessage=Now;
	G_Team2WonAttack=True;
	G_Team1WonDefense=False;
	
	foreach (Pole in BlockPoles){
		if(Pole.Gauge.Clan == 2){
			Pole.Gauge.ValueReal = 1.0;
		}
	}
	G_Pole2Captured = True;
	G_RoundScores[2]+=1;
	UpdateHeader();
	//Unspawn Player
	UnspawnPlayer(Players[G_Team2AttackingPlayer]);
}
Void Team1WonDefense(){
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::Warning;
	UIManager.UIAll.BigMessageSoundVariant = 0;
	//UIManager.UIAll.StatusMessage = """$<{{{Teams[0].ColorText}}}{{{Teams[0].Name}}} defense$> stopped $<{{{Players[G_Team2AttackingPlayer].Name}}}$>""";
	declare Name= "???"; 
	if(Players.existskey(G_Team2AttackingPlayer)){
		Name = Players[G_Team2AttackingPlayer].Name;
	}
	UIManager.UIAll.StatusMessage = TextLib::Compose(_("$<%1$> defense stopped $<%2$>"), Teams[0].ColorizedName, Name);
	UIManager.UIAll.SendNotice(
		UIManager.UIAll.StatusMessage,
		CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
		CUIConfig::EUISound::Silence, 0);
	G_LastStatusMessage=Now;
	if(S_GetAPointForDefense){
		G_RoundScores[1]+=1;
	}
	UpdateHeader();
	G_Team1WonDefense=True;
	G_Team2WonAttack=False;
}
Void Team2WonDefense(){
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::Warning;
	UIManager.UIAll.BigMessageSoundVariant = 0;
	//UIManager.UIAll.StatusMessage = """$<{{{Teams[1].ColorText}}}{{{Teams[1].Name}}} defense$> stopped $<{{{Players[G_Team1AttackingPlayer].Name}}}$>""";
	declare Name= "???"; 
	if(Players.existskey(G_Team1AttackingPlayer)){
		Name = Players[G_Team1AttackingPlayer].Name;
	}
	UIManager.UIAll.StatusMessage = TextLib::Compose(_("$<%1$> defense stopped $<%2$>"), Teams[1].ColorizedName, Name);
	UIManager.UIAll.SendNotice(
		UIManager.UIAll.StatusMessage,
		CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
		CUIConfig::EUISound::Silence, 0);
	G_LastStatusMessage=Now;
	if(S_GetAPointForDefense){
		G_RoundScores[2]+=1;
	}
	UpdateHeader();
	G_Team2WonDefense=True;
	G_Team1WonAttack=False;
}
//ResetPoleUI
Void ResetPoleUI(CSmBlockPole Pole){
	if(Pole.Gauge.Clan == 1 && Players.existskey(G_Team1AttackingPlayer)){
		G_LastPlayerPoleUI.add(Players[G_Team1AttackingPlayer]);
	}
	else if(Pole.Gauge.Clan == 2 && Players.existskey(G_Team1AttackingPlayer)){
		G_LastPlayerPoleUI.add(Players[G_Team2AttackingPlayer]);
	}
	G_LastPoleUI=Now;
}
Void ResetPoleUIPlayer(CSmPlayer Player){

	if(Players.existskey(Player.Id)){
		declare UI <=> UIManager.GetUI(Player);
		if (UI != Null) {
			UI.GaugeRatio = -1.;
			UI.GaugeMessage = "";
			UI.GaugeClan = 0;
		}
	}
}

//Create Attacker Marker
Text CreateAttackerMarker(Integer Clan){


declare ManiaLink = "";
	if(Clan==1){
	declare LayerAttached = Layers::Attach("PlayerMarkersTeam1", NullId);
	declare LayerUpdated = Layers::Update("PlayerMarkersTeam1", """<frame id="AtkMarker"><quad sizen="6 6" halign="center" valign="bottom" image="file://Media/Manialinks/ShootMania/Common/LaserWhite.dds" /></frame>""");
	
		ManiaLink ^="""<marker playerlogin="{{{TextLib::MLEncode(Players[G_Team1AttackingPlayer].Login)}}}" manialinkframeid="AtkMarker" box="0 1.85 0" />""";
	}else if(Clan == 2){
	declare LayerAttached = Layers::Attach("PlayerMarkersTeam2", NullId);
	declare LayerUpdated = Layers::Update("PlayerMarkersTeam2", """<frame id="AtkMarker"><quad sizen="6 6" halign="center" valign="bottom" image="file://Media/Manialinks/ShootMania/Common/LaserWhite.dds" /></frame>""");
	
		ManiaLink ^="""<marker playerlogin="{{{TextLib::MLEncode(Players[G_Team2AttackingPlayer].Login)}}}" manialinkframeid="AtkMarker" box="0 1.85 0" />""";
	}
	
	log(ManiaLink);
	return ManiaLink;
}

//StartServer
Void InitGameSettings() {
G_UseLaserVsBullets=S_UseLaserVsBullets;
UseClans = True;
UseForcedClans = True;
//UIManager.UIAll.NoticesFilter_HideMapWarning = True;
SM::SetupDefaultVisibility();
if(!S_GetAPointForDefense){
	SpawnScreen::CreateRules("Legends", Description, False);
}else{
	SpawnScreen::CreateRules("Legends", DescriptionWithDefensePoints, False);
}

G_MapScores	= [1 => 0, 2 => 0];
G_RoundScores = [1 => 0, 2 => 0];
UpdateHeader();

}
//StartMap
Void InitUI() {
UIManager.UIAll.BigMessage = "";
G_LastBigMessage=0;
G_LastStatusMessage=0;
UIManager.UIAll.StatusMessage = "";


}
Void InitLayers() {
// Layers
//AtkMarkers
declare LayerPlayerMarkersTeam1Id = Layers::Create("PlayerMarkersTeam1");

declare LayerPlayerMarkersTeam2Id = Layers::Create("PlayerMarkersTeam2");

Layers::GetFromId(LayerPlayerMarkersTeam1Id).Type = CUILayer::EUILayerType::Markers;
Layers::GetFromId(LayerPlayerMarkersTeam2Id).Type = CUILayer::EUILayerType::Markers;

LayerScores <=> UIManager.UILayerCreate();
LayerScores.Type = CUILayer::EUILayerType::ScoresTable;
//LayerScores.ManialinkPage = CreateLayerScoresTableElite();
//LayerScores.ManialinkPage = CreateLayerScoresTable();
UIManager.UIAll.UILayers.add(LayerScores);
UIManager.UIAll.ScoreTableOnlyManialink = True;

// Teams layer
LayerTeams <=> UIManager.UILayerCreate();
Interface::SetLayerTeams(LayerTeams);
UIManager.UIAll.UILayers.add(LayerTeams);
// Position layer
LayerPosition <=> UIManager.UILayerCreate();
Interface::SetLayerPosition(LayerPosition);
// Match information layer
/*
LayerInformation <=> UIManager.UILayerCreate();
//LayerInformation.ManialinkPage = GetLayerInformation();
UIManager.UIAll.UILayers.add(LayerInformation);
LayerInformation.IsVisible = True;
*/
LayerScores.IsVisible = True;
LayerTeams.IsVisible = True;

//LayerMarkers.IsVisible = True;
//LayerScores.ManialinkPage = CreateLayerScoresTable();
// Scores table

}
Void InitValues() {
UseLaserVsBullets = G_UseLaserVsBullets;
G_RoundCounter=0;
UseAmmoBonusOnHit = S_UseAmmoBonusOnHit;
G_RoundScores = [1 => 0, 2 => 0];
G_RestartNeeded=False;
G_FreeMode = S_FreeMode;
//G_AttackPoints.clear();
G_LongestLaserDist = 0.;
G_LongestLaserName = "";
}
Void PrepareMatch() {
Score::MatchBegin();
Victory::MatchBegin();

}
Void InitBases() {
log("reset pole and spawns");
	declare Integer clan1;
	declare Integer clan2;
	
	if(G_RoundCounter%2==0){
		clan1=1;
		clan2=2;
	}else{
		clan1=2;
		clan2=1;
	}
	
	foreach (Spawn in BlockSpawns) {
		if(Spawn.Order==1){
			Spawn.Base.Clan=clan1;
			Spawn.Base.IsActive = True;
		}else if(Spawn.Order==2){
			Spawn.Base.Clan=clan2;
			Spawn.Base.IsActive = True;
		}else{
			log("no spawn found");
		}
	}
	
	foreach (Pole in BlockPoles){
		if(Pole.Order==1){
			Pole.Gauge.ValueReal = 0.0;
			Pole.Base.Clan = clan1;
			Pole.Gauge.Clan = clan1;
		}else if(Pole.Order==2){
			Pole.Gauge.ValueReal = 0.0;
			Pole.Base.Clan = clan2;
			Pole.Gauge.Clan = clan2;
		}
		Pole.Gauge.Speed=0;
	}
}

Void InitPoles() {
foreach (Pole in BlockPoles){
	Pole.Gauge.Max = MathLib::NearestInteger(S_CaptureTime * 1000);
}

}
Void StartWarmup() {
	
	log("warmup");
	UseClans = True;
	/*
	if(G_FreeMode){
		WarmUp::Before(S_WarmUpDuration, True, True, 2);
	}else{
		WarmUp::Before(S_WarmUpDuration, True, True, C_PlayerNeeded/2);
	}*/
	
	if(C_UseBots){
		G_BlueBots=S_BlueBots;
		G_RedBots=S_RedBots;
		Users_SetNbFakeUsers(G_BlueBots,G_RedBots);
	}
	//LayerScores.IsVisible = False;
	DoWarmUp();
	//LayerScores.IsVisible = True;
	
	
}

//StartRound
Void InitRoundValues(){
	StartTime = Now+3500;
	EndTime = StartTime+(S_AttackTimeLimit+S_CaptureTimeLimit)*1000;
	UIManager.UIAll.CountdownEndTime=StartTime+S_AttackTimeLimit*1000;
	G_CapturingPossible = False;
	G_Pole1Captured = False;
	G_Pole2Captured = False;
	G_DefenderTeam1TimeToBeRespawned.clear();
	G_DefenderTeam2TimeToBeRespawned.clear();
	G_Team1WonDefense = False;
	G_Team2WonDefense = False;
	G_Team1WonAttack = False;
	G_Team2WonAttack = False;
	G_Playing= False;
	foreach (Score in Scores) {
		declare Integer WonAttackRounds for Score;
		WonAttackRounds = 0;
		declare Integer DefendHits for Score;
		DefendHits = 0;
	}

	G_AttackerMarkerTime[1]=0;
	G_AttackerMarkerTime[2]=0;
}
Void PrepareRound() {
	SM::UnspawnAllPlayers();
	Score::RoundBegin();
	Victory::RoundBegin();
	
}

Void CheckWarmup() {
if(G_FreeMode){
	if(PlayersNbTotal<4){
		StartWarmup();
	}
}else{
	if (PlayersNbTotal < C_PlayerNeeded) {
		StartWarmup();
	}
}


}
Void SetTeams() {
	G_Team1Players.clear();
	G_Team2Players.clear();
	//G_PlayingPlayers.clear();
	foreach(Player in Players){
	if(Player.CurrentClan==1){
		if(G_Team1Players.count<C_MaxPlayers/2){
			G_Team1Players.add(Player.Id);
			//G_PlayingPlayers.add(Player);
		}
	}else if(Player.CurrentClan==2){
		if(G_Team2Players.count<C_MaxPlayers/2){
			G_Team2Players.add(Player.Id);
			//G_PlayingPlayers.add(Player);
		}
	}
	
}

}
Void SetRoles() {

/*
declare I = 1;
foreach(Id => Order in G_MapOrder[1]){
	log(Id);
	if(Players.existskey(Id)){
		G_MapOrder[1][Id] = I;
	}
	I+=1;
}
I = 1;
foreach(Id => Order in G_MapOrder[2]){
	if(Players.existskey(Id)){
		G_MapOrder[2][Id] = I;
	}
	I+=1;
}*/
//Team1
G_Team1DefenderPlayers.clear();
/*
declare MapOrderTeam1 = G_MapOrder[1];
foreach(Id => Order in MapOrderTeam1){
	log("Order "^Order);
	if(Order == 1+G_RoundCounter%G_Team1Players.count){
		G_Team1AttackingPlayer=Players[Id].Id;
	}
}*/declare NextAtk1Player <=> WarmUp::GetNextPlayer(1);
G_Team1AttackingPlayer = NextAtk1Player.Id;
//G_Team1AttackingPlayer=G_Team1Players[MapOrderTeam1[G_RoundCounter%G_Team1Players.count]];
foreach(PlayerId in G_Team1Players){
	if(PlayerId!=G_Team1AttackingPlayer){
		G_Team1DefenderPlayers.add(PlayerId);
	}
}
//Team2

G_Team2DefenderPlayers.clear();
/*
declare MapOrderTeam2 = G_MapOrder[2];
foreach(Id => Order in MapOrderTeam2){
	if(Order == 1+G_RoundCounter%G_Team2Players.count){
		G_Team2AttackingPlayer=Players[Id].Id;
	}
}*/declare NextAtk2Player <=> WarmUp::GetNextPlayer(2);
G_Team2AttackingPlayer = NextAtk2Player.Id;
	
//G_Team2AttackingPlayer=G_Team1Players[MapOrderTeam2[G_Team2Players[G_RoundCounter%G_Team2Players.count]]];
//G_Team2AttackingPlayer=G_Team2Players[G_Team2Players.count-(G_RoundCounter%G_Team2Players.count)-1];
foreach(PlayerId in G_Team2Players){
	if(PlayerId!=G_Team2AttackingPlayer){
		G_Team2DefenderPlayers.add(PlayerId);
	}
}
WarmUp::CycleOrder(1);
WarmUp::CycleOrder(2);

}
Void SetSpawnsAndPoles() {
	InitBases();
}
Void AnnounceAttackers() {
UIManager.UIAll.BigMessage = """$<{{{Players[G_Team1AttackingPlayer].Name}}}$> VS $<{{{Players[G_Team2AttackingPlayer].Name}}}$>""";
UIManager.UIAll.SendNotice(
		UIManager.UIAll.BigMessage,
		CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
		CUIConfig::EUISound::Silence, 0);
G_LastBigMessage = Now;
}
Void StartPlay() {
	log("startRound "^G_RoundCounter);
	InitRoundValues();
	if(S_UseSimpleScore){
		LayerScores.ManialinkPage = CreateLayerScoresTable();
	}else{
		LayerScores.ManialinkPage = CreateLayerScoresTableElite();
		UpdateLayerScoresTable(C_SequencePlaying);
	}
	
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
	InitialMarkers(0);
	
	
}
//OnNewPlayer
Void EditUI(CSmPlayer Player) {
declare UI <=> UIManager.GetUI(Player);
if (UI != Null) {
	UI.UILayers.clear();
	UI.UILayers.add(LayerScores);
	UI.UILayers.add(LayerTeams);
	UI.UILayers.add(LayerPosition);
	UI.UILayers.add(LayerInformation);
	UI.UILayers.add(LayerMarkers);
	UI.SpectatorForcedClan = Player.RequestedClan;
}
}
Void EditValues(CSmPlayer Player) {
/*
	log(ClansNbPlayers[1]^" clans "^ClansNbPlayers[2]);
	if(Players[Player.Id]==Null){
		if(ClansNbPlayers[1]<ClansNbPlayers[2]){
			This.SetPlayerClan(Player, 1);
		}else if(ClansNbPlayers[1]>ClansNbPlayers[2]){
			This.SetPlayerClan(Player, 2);
		}else{
			This.SetPlayerClan(Player, 1);
		}
	}
*/
}
//OnNewSpectator
Void PrepareUIForSpectator(CSmPlayer Spectator) {
// Prepare UI for the new spectator
declare UI <=> UIManager.GetUI(Spectator);
if (UI != Null) {
	UI.UILayers.clear();
	
	// Spectating
	UI.SpectatorForcedClan = -1;
}
}
//PlayLoop
Void UpdateUI(){
	CheckSettings(False);
	UpdateLayerScoresTable(C_SequencePlaying);
	if(Now>= StartTime-3000 && !G_Playing){
		UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
		
		G_Playing = True;
	}
	//Big Message Handle
	if (G_LastBigMessage!=0 && Now >= G_LastBigMessage + C_BigMessageTime) {
		log("BigMessage reset");
		G_LastBigMessage=0;
		UIManager.UIAll.BigMessage = "";
	}
	//Status Message Handle
	if (G_LastStatusMessage!=0 && Now >= G_LastStatusMessage + C_StatusMessageTime) {
		log("StatusMessage reset");
		G_LastStatusMessage=0;
		UIManager.UIAll.StatusMessage = "";
	}
	//PoleUI Handle
	if(G_LastPoleUI!=0 && Now >= G_LastPoleUI + C_PoleUITime){
		foreach(Player in G_LastPlayerPoleUI){
		declare UI <=> UIManager.GetUI(Player);
			if (UI != Null) {
				UI.GaugeRatio = -1.;
				UI.GaugeMessage = "";
				UI.GaugeClan = 0;
			}
		} 
		G_LastPlayerPoleUI.clear();
	}
	//AttackerMarker handle
	if(G_AttackerMarkerTime[1]!=0 && Now >= G_AttackerMarkerTime[1]){
		declare LayerDetached = Layers::Detach("PlayerMarkersTeam1", NullId);
		InitialMarkers(1);
		G_AttackerMarkerTime[1]=0;
		G_Team1MarkerCreated=False;
	}
	if(G_AttackerMarkerTime[2]!=0 && Now >= G_AttackerMarkerTime[2]){
		declare LayerDetached = Layers::Detach("PlayerMarkersTeam2", NullId);
		InitialMarkers(2);
		G_AttackerMarkerTime[1]=0;
		G_Team1MarkerCreated=False;
	}
}
Void SpawnPlayers() {
	if(Now<=StartTime){
	foreach (Player in Players) {
	
	switch (Player.SpawnStatus) {
		case CSmPlayer::ESpawnStatus::NotSpawned: {
			// Player not spawned -> Spawn him!
			//log(Now^" startTime: "^StartTime);
			if (!Player.RequestsSpectate && Player.CurrentClan!=0) {
				SpawnThePlayer(Player);
				//UpdateMarkers(Player);
			} else if(!Player.RequestsSpectate){
				//New Player
				if(ClansNbPlayers[1]<ClansNbPlayers[2]){
					This.SetPlayerClan(Player, 1);
				}else if(ClansNbPlayers[1]>ClansNbPlayers[2]){
					This.SetPlayerClan(Player, 2);
				}else{
					This.SetPlayerClan(Player, 1);
				}
				SpawnThePlayer(Player);
			}
		}
	}
	
	}
	
	}
}
Void HandlePendingEvents() {
foreach (Event in PendingEvents) {
	
	if(S_UseSimpleScore){
		LayerScores.ManialinkPage = CreateLayerScoresTable();
	}else{
		LayerScores.ManialinkPage = CreateLayerScoresTableElite();
		UpdateLayerScoresTable(C_SequencePlaying);
	}
	switch (Event.Type) {
		case CSmModeEvent::EType::OnHit: {
				Event.Damage=100;
				if (Event.Shooter == Null || Event.Victim == Null) {
					// Discard buggy event
					Discard(Event);
				}else if(Event.Shooter == Event.Victim){
					Discard(Event);
				}else if(Event.Shooter.CurrentClan == Event.Victim.CurrentClan){
					if (S_FriendlyFire) {
							// PassOn team hits
							declare Points = -1;
							Event.ShooterPoints = Points;
							if (Event.Shooter.Score != Null) {
									declare Integer DefendHits for Event.Shooter.Score = 0;
									DefendHits += Event.ShooterPoints;
							}
							PassOn(Event);
						} else {
							// Discard team hits
							Discard(Event);
						}
			
				}else if(Event.Shooter.CurrentClan != Event.Victim.CurrentClan){
					if(Event.Shooter.Id == G_Team1AttackingPlayer){
						if(Event.Victim.Id == G_Team2AttackingPlayer){
							//Ping Victim
							if(!G_Team1MarkerCreated){
							foreach(PlayerId in G_Team1Players){
								if(Players.existskey(PlayerId)){
									declare UI <=> UIManager.GetUI(Players[PlayerId]);
									if (UI != Null ) {
										UI.Hud3dMarkers ^= CreateAttackerMarker(2);
										
									}
								}
							}
							G_Team1MarkerCreated=True;
							}
							G_AttackerMarkerTime[2]=Now+S_AttackerPingTime*1000;
							//declare LayerAttached = Layers::Attach("PlayerMarkersTeam2", NullId);
							Event.ShooterPoints = 0;
							Event.Damage= 0;
							PassOn(Event);
						}else{
							PassOn(Event);
						}
						
					}else if(Event.Shooter.Id == G_Team2AttackingPlayer){
						if(Event.Victim.Id == G_Team1AttackingPlayer){
							//Ping Victim
							if(!G_Team1MarkerCreated){
							foreach(PlayerId in G_Team2Players){
								if(Players.existskey(PlayerId)){
									declare UI <=> UIManager.GetUI(Players[PlayerId]);
									if (UI != Null) {
										UI.Hud3dMarkers ^= CreateAttackerMarker(1);
										G_Team2MarkerCreated=True;
									}
								}
							}
							G_Team1MarkerCreated=True;
							}
							G_AttackerMarkerTime[2]=Now+S_AttackerPingTime*1000;
							//declare LayerAttached = Layers::Attach("PlayerMarkersTeam1", NullId);
							Event.ShooterPoints = 0;
							Event.Damage=0;
							PassOn(Event);
						}else{
							PassOn(Event);
						}
					}else{
						if(Event.Shooter.CurrentClan == 1){
							if(Event.Victim.Id == G_Team2AttackingPlayer){
								Event.ShooterPoints = 1;
								if (Event.Shooter.Score != Null) {
									declare Integer DefendHits for Event.Shooter.Score = 0;
									DefendHits += Event.ShooterPoints;
									Event.Shooter.Score.Points += Event.ShooterPoints;
								}
								PassOn(Event);
							}else{
								//Def vs Def
								Event.ShooterPoints = 0;
								if(S_DefenderRespawnTime>0){
								G_DefenderTeam2TimeToBeRespawned[Event.Victim.Id] = Now + S_DefenderRespawnTime*1000;
								PassOn(Event);
								}else{
									//Event.Damage=99;
									Discard(Event);
								}
								
							}
						}
						if(Event.Shooter.CurrentClan ==2){
							if(Event.Victim.Id == G_Team1AttackingPlayer){
								Event.ShooterPoints = 1;
								PassOn(Event);
							}else{
								//Def vs Def
								Event.ShooterPoints = 0;
								if(S_DefenderRespawnTime>0){
								G_DefenderTeam1TimeToBeRespawned[Event.Victim.Id] = Now + S_DefenderRespawnTime*1000;
								PassOn(Event);
								}else{
									//Event.Damage=99;
									Discard(Event);
								}
								
							}
						}
					}
				}
			}
		case CSmModeEvent::EType::OnArmorEmpty: {
			if (Event.Shooter != Null && (Event.Shooter.Id == G_Team1AttackingPlayer || Event.Shooter.Id == G_Team2AttackingPlayer)) {
				DisplayHitDistance(Event.Shooter, Event.Victim, False);
				declare LaserLongest for Event.Shooter.Score = 0.;
				declare Distance = MathLib::Distance(Event.Shooter.Position, Event.Victim.Position);
				if (Distance > LaserLongest) LaserLongest = Distance;
					}
				PassOn(Event);
			}
		case CSmModeEvent::EType::OnCapture: {
				if(Event.BlockPole.Gauge.Clan == 1){
					if(!G_Pole1Captured){
						G_Pole1Captured=True;
						//Attack successfull
						log("Pole 1 captured");
						ResetPoleUI(Event.BlockPole);
						Team1WonAttack();
						PassOn(Event);
					}
				}
				else if(Event.BlockPole.Gauge.Clan == 2){
					if(!G_Pole2Captured){
						G_Pole2Captured=True;
						//Attack successfull
						log("Pole 2 captured");
						ResetPoleUI(Event.BlockPole);
						Team2WonAttack();
						PassOn(Event);
					}
			
				}else{
					Discard(Event);
				}
				
			}
		case CSmModeEvent::EType::OnNearMiss: {
				PassOn(Event);
			}
		case CSmModeEvent::EType::OnPlayerRequestRespawn: {
				PassOn(Event);
			}
		default: {
			PassOn(Event);
		}
	}
}
}
Void ActivateGoal() {
if (Now >= StartTime + S_AttackTimeLimit*1000 && Now<EndTime) {
	if (!G_CapturingPossible) {
		log("Cap time");
		G_CapturingPossible = True;
		UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::PhaseChange;
		UIManager.UIAll.BigMessageSoundVariant = 0;
		UIManager.UIAll.StatusMessage = _("The goal can now be captured.");
		UIManager.UIAll.CountdownEndTime = -1;
		G_LastStatusMessage=Now;
	}
}
}
Void CheckForCapture(){
foreach (Pole in BlockPoles) {
	if (G_CapturingPossible) {
		//if((!G_Team1WonAttack && Pole.Gauge.Clan == 1) || (!G_Team2WonAttack && Pole.Gauge.Clan == 2)){
			if(Pole.Sector.PlayersIds.count > 0){
				foreach(PlayerId in Pole.Sector.PlayersIds){
			
					if(Pole.Gauge.Clan == 1 && PlayerId == G_Team1AttackingPlayer && Players[PlayerId].SpawnStatus==CSmPlayer::ESpawnStatus::Spawned){
						declare UI <=> UIManager.GetUI(Players[PlayerId]);
						if (UI != Null) {
							UI.GaugeRatio = Pole.Gauge.ValueReal;
							UI.GaugeMessage = MathLib::FloorInteger(Pole.Gauge.ValueReal * 100)^"%";
							UI.GaugeClan = Players[PlayerId].CurrentClan;
							G_LastPlayerPoleUI.add(Players[PlayerId]);
							G_LastPoleUI=Now;
							
						}
						Pole.Gauge.Speed = 1;
					}else if(Pole.Gauge.Clan ==2 && PlayerId == G_Team2AttackingPlayer && Players[PlayerId].SpawnStatus==CSmPlayer::ESpawnStatus::Spawned){
						declare UI <=> UIManager.GetUI(Players[PlayerId]);
						if (UI != Null) {
							UI.GaugeRatio = Pole.Gauge.ValueReal;
							UI.GaugeMessage = MathLib::FloorInteger(Pole.Gauge.ValueReal * 100)^"%";
							UI.GaugeClan = Players[PlayerId].CurrentClan;
							G_LastPlayerPoleUI.add(Players[PlayerId]);
							G_LastPoleUI=Now;
							
						}
						
						Pole.Gauge.Speed = 1;
					}
				}
			}else{
			Pole.Gauge.Speed=0;
		}
		}else{
			Pole.Gauge.Speed=0;
		}
	}//else{
		//Pole.Gauge.Speed=0;
	//}
	//}
}
Void RespawnDefender() {
	foreach(PlayerId => Time in G_DefenderTeam1TimeToBeRespawned){
	
		if(Time != 0 && Now >= Time){
			SpawnThePlayer(Players[PlayerId]);
			G_DefenderTeam1TimeToBeRespawned[PlayerId] = 0;
			
		}
	}
	foreach(PlayerId => Time in G_DefenderTeam2TimeToBeRespawned){
	
		if(Time != 0 && Now >= Time){
			SpawnThePlayer(Players[PlayerId]);
			G_DefenderTeam2TimeToBeRespawned[PlayerId] = 0;
			
		}
	}
}


Void SetPoints() {
//Check attacker 1
if(Players.existskey(G_Team1AttackingPlayer) && !G_Team1WonAttack && Now>=StartTime && Players[G_Team1AttackingPlayer].SpawnStatus==CSmPlayer::ESpawnStatus::NotSpawned && !G_Team2WonDefense){
	Team2WonDefense();
}else if(!Players.existskey(G_Team1AttackingPlayer)){
	Team2WonDefense();
}
//Check attacker 2
if(Players.existskey(G_Team2AttackingPlayer) && !G_Team2WonAttack && Now>=StartTime && Players[G_Team2AttackingPlayer].SpawnStatus==CSmPlayer::ESpawnStatus::NotSpawned && !G_Team1WonDefense){
	Team1WonDefense();
}else if(!Players.existskey(G_Team1AttackingPlayer)){
	Team1WonDefense();
}
//Check Defense 1
if(!G_Team2WonAttack && !G_Team1WonDefense){
declare Team1DefKilled =0;
foreach(PlayerId in G_Team1DefenderPlayers){
	if(!Players.existskey(PlayerId) || Players[PlayerId].SpawnStatus ==CSmPlayer::ESpawnStatus::NotSpawned){
		Team1DefKilled+=1;
	}
}
foreach(PlayerId => Time in G_DefenderTeam1TimeToBeRespawned){
	if(Time>0){
		Team1DefKilled-=1;
	}
}
	if(Team1DefKilled>=G_Team1DefenderPlayers.count){
		//Attacker2 won
		Team2WonAttack();
	}
}

//Check Defense 2
if(!G_Team1WonAttack && !G_Team2WonDefense){
	declare Team2DefKilled =0;
foreach(PlayerId in G_Team2DefenderPlayers){
	if(!Players.existskey(PlayerId) || Players[PlayerId].SpawnStatus ==CSmPlayer::ESpawnStatus::NotSpawned){
		Team2DefKilled+=1;
	}
}
foreach(PlayerId => Time in G_DefenderTeam2TimeToBeRespawned){
	if(Time>0){
		Team2DefKilled-=1;
	}
}
	if(Team2DefKilled>=G_Team2DefenderPlayers.count){
		//Attacker2 won
		Team1WonAttack();
	}
}

if(G_Team1WonAttack && G_Team2WonAttack){
log("team1 and team2 won attack");
UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::EndRound;
UIManager.UIAll.BigMessageSoundVariant = 0;
UIManager.UIAll.BigMessage = TextLib::Compose(_("Draw! $<%1$> and $<%2$> get 1 Point!"), Teams[0].ColorizedName, Teams[1].ColorizedName);
UIManager.UIAll.SendNotice(
UIManager.UIAll.BigMessage,
CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
CUIConfig::EUISound::Silence, 0);

G_LastBigMessage=Now;
	MB_StopRound = True;
}
if(G_Team1WonAttack && G_Team1WonDefense){
log("team1 won attack and defense");
UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::EndRound;
UIManager.UIAll.BigMessageSoundVariant = 0;
if(G_RoundScores[1]==G_RoundScores[2]){
	UIManager.UIAll.BigMessage = TextLib::Compose(_("Back in the game! $<%1$> win the round!"), Teams[0].ColorizedName);
}else if(G_RoundScores[1]==G_RoundScores[2]+1 && !S_GetAPointForDefense){
	UIManager.UIAll.BigMessage = TextLib::Compose(_("Break advantage! $<%1$> win the round!"), Teams[0].ColorizedName);
}else if(G_RoundScores[1]==G_RoundScores[2]+2 && S_GetAPointForDefense){
	UIManager.UIAll.BigMessage = TextLib::Compose(_("Break advantage! $<%1$> win the round!"), Teams[0].ColorizedName);
}else{
	UIManager.UIAll.BigMessage = TextLib::Compose(_("$<%1$> win the round!"), Teams[0].ColorizedName);
}
UIManager.UIAll.SendNotice(
UIManager.UIAll.BigMessage,
CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
CUIConfig::EUISound::Silence, 0);

G_LastBigMessage=Now;
	MB_StopRound = True;
}
if(G_Team2WonAttack && G_Team2WonDefense){
log("team2 won attack and defense");
UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::EndRound;
UIManager.UIAll.BigMessageSoundVariant = 0;
if(G_RoundScores[2]<=G_RoundScores[1]){
	UIManager.UIAll.BigMessage = TextLib::Compose(_("Back in the game! $<%1$> win the round!"), Teams[1].ColorizedName);
}else if(G_RoundScores[2]==G_RoundScores[1]+1 && !S_GetAPointForDefense){
	UIManager.UIAll.BigMessage = TextLib::Compose(_("Break advantage! $<%1$> win the round!"), Teams[1].ColorizedName);
}else if(G_RoundScores[2]==G_RoundScores[1]+2 && S_GetAPointForDefense){
	UIManager.UIAll.BigMessage = TextLib::Compose(_("Break advantage! $<%1$> win the round!"), Teams[1].ColorizedName);
}else{
	UIManager.UIAll.BigMessage = TextLib::Compose(_("$<%1$> win the round!"), Teams[1].ColorizedName);
}

UIManager.UIAll.SendNotice(
UIManager.UIAll.BigMessage,
CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
CUIConfig::EUISound::Silence, 0);

G_LastBigMessage=Now;
	MB_StopRound = True;
}
if(G_Team1WonDefense && G_Team2WonDefense){
log("team1 and team2 won defense");
UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::EndRound;
UIManager.UIAll.BigMessageSoundVariant = 0;
if(S_GetAPointForDefense){
	UIManager.UIAll.BigMessage = TextLib::Compose("%1 $<%2$> %3 $<%4$> %5",_("Draw!"), Teams[0].ColorizedName,_("and"), Teams[1].ColorizedName,_("get 1 Point!"));
}else{
	UIManager.UIAll.BigMessage = TextLib::Compose("%1 $<%2$> %3 $<%4$> %5",_("Draw!"), Teams[0].ColorizedName,_("and"), Teams[1].ColorizedName,_("get 0 Point!"));
}

UIManager.UIAll.SendNotice(
UIManager.UIAll.BigMessage,
CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
CUIConfig::EUISound::Silence, 0);

G_LastBigMessage=Now;
	MB_StopRound = True;
}

//EndTime
if (!MB_StopRound && Now>=EndTime) {
	G_CapturingPossible = False;
	SM::UnspawnAllPlayers();
	// Round winner found
	foreach(Pole in BlockPoles){
		if(Pole.Gauge.ValueReal<1.0){
			if(Pole.Gauge.Clan==2 && !G_Team2WonAttack && !G_Team1WonDefense){
			log("Pole not cap, team1def win");
				Team1WonDefense();
			}else if(Pole.Gauge.Clan==1 && !G_Team1WonAttack && !G_Team2WonDefense){
			log("Pole not cap, team2def win");
				Team2WonDefense();
			}
		}
		
	}
	
}


}


//EndRound
Void AttributePoints() {
	Score::RoundEnd();
	Victory::RoundEnd();
	SM::UnspawnAllPlayers();
	foreach (Player in Players) {
	if (Player.Score == Null) continue;
		Player.Score.LadderClan = Player.CurrentClan;
	}
	if(S_UseSimpleScore){
		LayerScores.ManialinkPage = CreateLayerScoresTable();
	}else{
		LayerScores.ManialinkPage = CreateLayerScoresTableElite();
		UpdateLayerScoresTable(C_SequencePodium);
	}
	EndTime=Now;
	G_RoundCounter+=1;
}
Void DisplayResults() {
sleep(MathLib::NearestInteger(S_TimeBetweenRounds*1000/2));
log("sleep");

declare LayerDetached = Layers::Detach("PlayerMarkersTeam1", NullId);
LayerDetached = Layers::Detach("PlayerMarkersTeam2", NullId);

foreach(Player in Players){
		if(Players.existskey(Player.Id)){
			ResetPoleUIPlayer(Player);
			UIManager.GetUI(Player).Hud3dMarkers = "";
		}
	}
sleep(MathLib::NearestInteger(S_TimeBetweenRounds*1000/2));
}
Void GiveLadderPoints(Integer WinnerClan){
	// Give Ladder Points
	UpdateLayerScoresTable(C_SequencePodium);
foreach (Score in Scores) {
	declare PrevPoints for Score = 0;
	declare WonAttackRounds for Score = 0;
	PrevPoints = Score.Points;
	Score.LadderMatchScoreValue = (Score.Points * 1.);
	// Winner
	if (Score.LadderClan == WinnerClan) {
		Score.LadderMatchScoreValue *= 2.;
		Score.Points = 3;
	}
	// Looser
	else if (Score.LadderClan == 3 - WinnerClan) {
		Score.LadderMatchScoreValue *= 1.;
		Score.Points = 2;
	}
	// Other
	else {
		Score.LadderMatchScoreValue *= 0.5;
		Score.Points = 1;
	}
}
Ladder_SetResultsVersion(1);
Score::MatchEnd(True);
foreach (Score in Scores) {
	declare PrevPoints for Score = 0;
	Score.Points = PrevPoints;
}
UpdateLayerScoresTable(C_SequencePodium);
}

Void EndMap() {
log("End Map");
declare LayerDestroyed = Layers::Destroy("PlayerMarkersTeam1");
LayerDestroyed = Layers::Destroy("PlayerMarkersTeam2");
foreach (Score in Scores) {
		declare Integer WonAttackRounds for Score;
		WonAttackRounds = 0;
		declare Integer DefendHits for Score;
		DefendHits = 0;
		declare Real LaserLongest for Score;
		LaserLongest = 0.;
	}
if(G_MapScores[1]>=S_MapsToWin){
	G_MapScores = [1 => 0, 2 => 0];
	UpdateHeader();
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::EndRound;
	UIManager.UIAll.BigMessageSoundVariant = 0;
	UIManager.UIAll.BigMessage = TextLib::Compose(_("$<%1$> %2"), Teams[0].ColorizedName,"wins the match!");
	UIManager.UIAll.SendNotice(
		UIManager.UIAll.BigMessage,
		CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
		CUIConfig::EUISound::Silence, 0);
	G_LastBigMessage=Now;
	GiveLadderPoints(1);
	
	
}else if(G_MapScores[2]>=S_MapsToWin){
	G_MapScores = [1 => 0, 2 => 0];
	UpdateHeader();
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::EndRound;
	UIManager.UIAll.BigMessageSoundVariant = 0;
	UIManager.UIAll.BigMessage = TextLib::Compose(_("$<%1$> %2"), Teams[1].ColorizedName,"wins the match!");
	UIManager.UIAll.SendNotice(
		UIManager.UIAll.BigMessage,
		CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
		CUIConfig::EUISound::Silence, 0);
	G_LastBigMessage=Now;
	GiveLadderPoints(2);
}
UpdateLayerScoresTable(C_SequencePodium);
sleep(MathLib::NearestInteger(S_TimeBetweenRounds*1000));
MB_StopMap = True;

}
Void CheckMapEnd() {
if(G_RoundScores[1]>=S_PointLimitToWin || G_RoundScores[2]>=S_PointLimitToWin){
	if(G_RoundScores[2]>=G_RoundScores[1]+S_PointGapToWin){
		//Team 2 win
		log("Team2 win");
		G_MapScores[2]+=1;
		G_RoundScores = [1 => 0, 2 => 0];
		UpdateHeader();
		UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::EndMatch ;
		UIManager.UIAll.BigMessageSoundVariant = 1;
		UIManager.UIAll.BigMessage = TextLib::Compose(_("$<%1$> wins the map!"), Teams[1].ColorizedName);
		UIManager.UIAll.SendNotice(
		UIManager.UIAll.BigMessage,
		CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
		CUIConfig::EUISound::Silence, 0);
		G_LastBigMessage=Now;
		EndMap();
		
	}else if(G_RoundScores[1]>=G_RoundScores[2]+S_PointGapToWin){
		//Team 1 win
		log("Team1 win");
		G_MapScores[1]+=1;
		G_RoundScores = [1 => 0, 2 => 0];
		UpdateHeader();
		UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::EndMatch ;
		UIManager.UIAll.BigMessageSoundVariant = 1;
		UIManager.UIAll.BigMessage = TextLib::Compose(_("$<%1$> wins the map!"), Teams[0].ColorizedName);
		UIManager.UIAll.SendNotice(
		UIManager.UIAll.BigMessage,
		CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
		CUIConfig::EUISound::Silence, 0);
		G_LastBigMessage=Now;
		EndMap();
	}
	}
}
//EndMatch
Void EndMapUI() {
	Score::MatchEnd();
	Victory::MatchEnd();
}
//EndServer
Void Clean() {
SpawnScreen::DestroyRules();
UIManager.UILayerDestroyAll();
}
