/****************************************
*	Legends 4v4 Competition title		*
*	Author:		Platernity				*
*	Contact:	platernity@hotmail.fr	*
****************************************/

#Extends "Modes/ShootMania/ModeBase.Script.txt"

#Const	CompatibleMapTypes	"LegendsArena"
#Const	Version				"1.0"



/* INCLUDES */
#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/Interface.Script.txt" as Interface
#Include "Libs/Nadeo/Victory.Script.txt" as Victory
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen
#Include "Libs/Nadeo/ShootMania/WarmUp.Script.txt" as WarmUp
#Include "Libs/Nadeo/ShootMania/ScoresTable.Script.txt" as ScoresTable
#Include "Libs/Nadeo/Layers.Script.txt" as Layers
#Include "Libs/Nadeo/Json.Script.txt" as Json

/* SETTINGS */
#Setting	S_FreeMode					True	as _("Free Mode")
#Setting	S_AttackTimeLimit			45		as _("Attack time limit")
#Setting	S_CaptureTimeLimit			15		as _("Capture time limit")
#Setting	S_CaptureTime				1.5		as _("Time to capture pole")
#Setting	S_WarmUpDuration			90		as _("Warmup duration")
#Setting	S_PointGapToWin				2		as _("Point gap to win map")
#Setting	S_PointLimitToWin			9		as _("Point limit to win map")
#Setting	S_MapsToWin					3		as _("Maps to win to win match")
#Setting 	S_PointLimitDecisiveRound	15		as _("Decisive point limit")
#Setting 	S_TimeBetweenRounds			2.		as _("Time between Rounds")
#Setting 	S_UsePlayerClublinks		True	as _("Use player clublinks")
#Setting 	S_UseLaserVsBullets			True	as _("Use laser vs rockets")
#Setting	S_UseAmmoBonusOnHit			True	as _("Use Ammo reload on hit")
#Setting 	S_AttackerPingTime			3		as _("Attacker ping time on hit")
#Setting 	S_DefenderRespawnTime		1		as _("Defender respawn time on hit")
#Setting	S_FriendlyFire				False	as _("Friendly fire")

//To be removed
#Setting	S_BlueBots			0	as _("Blue bots")
#Setting	S_RedBots			0	as _("Red bots")

//* CONSTANTS */
#Const Description _("TYPE: Team versus Team (4 vs 4)\nOBJECTIVE:\nOne attacker plays against three defenders on each side. The attacker must capture the pole or eliminate the defenders. The defenders must eliminate the attacker or prevent him to capture the pole.\nThe attacker uses the Laser while the defenders have the Rocket.\nEach teams get 1 point for any successfull attack. First team to reach score limit win the map.")
#Const	C_PlayerNeeded	8 		//Number of players needed to start match
#Const	C_NoWarmUp		False	//For testing purposes only
#Const	C_UseBots		True	//For testing purposes only
#Const	C_UsePlayLoopLogs False	//For testing purposes only
#Const	C_AttackerAmmoGain			1.0			// Attacker ammunition gain rate
#Const	C_DefenderAmmoGain			1.0			// Defender ammunition gain rate
#Const	C_DefStaminaMaxMultiplier	0.7			// Defender Stamina multiplier
#Const	C_AttackerArmorMultiplier	1			// Attacker armor per Defender.
#Const	C_DefenderArmor				1			// Defender armor
#Const	C_BigMessageTime			2500		// Time BigMessage stay
#Const	C_StatusMessageTime			2500		// Time StatusMessage stay
#Const	C_PoleUITime				2000		// Time PoleUI stay

#Const	C_UI_Colors [
	"BG"		=> "fffa",
	"Separator"	=> "eeef",
	"Text"		=> "fffc"
]

#Const C_SequenceWarmUp			1	///< Scores table mode warm up
#Const C_SequencePlaying		2	///< Scores table mode playing
#Const C_SequencePodium			3	///< Scores table mode podium

/* GLOBALES */
declare	Boolean G_CapturingPossible;			// Whether it's possible to capture the goal
declare	Ident[]	G_Team1Players;					// All players from Team 1
declare	Ident[]	G_Team2Players;					// All players from Team 2
declare	Ident[]	G_Team1DefenderPlayers;			// All defender players from Team 1
declare	Ident[]	G_Team2DefenderPlayers;			// All defender players from Team 
declare	Ident	G_Team1AttackingPlayer;			// Attacking player from Team 1
declare	Ident	G_Team2AttackingPlayer;			// Attacking player from Team 2
declare Integer	G_RoundCounter;					// Actual round played
declare Boolean	G_Pole1Captured;
declare Boolean	G_Pole2Captured;
declare Integer[Ident] G_DefenderTimeToBeRespawned;		//List Times for defenders to be respawned
declare Ident[] G_DefenderKilledTeam1;			//List Defenders killed in team1
declare Ident[] G_DefenderKilledTeam2;			//List Defenders killed in team2
declare Boolean G_Team1WonDefense;				//
declare Boolean G_Team2WonDefense;				//
declare Boolean	G_Team1WonAttack;				//
declare Boolean	G_Team2WonAttack;				//
declare Integer G_BlueBots;
declare Integer G_RedBots;
declare CSmPlayer[]	G_PlayingPlayers;			//All Playing players
declare	Integer[Ident][Integer] G_MapOrder;		//Attack Order
declare Integer[Integer] G_InitDefHit;			///< Default values for the defenders hit


//Scores
declare Integer[Integer] G_MapScores;			// Number of map won by each clan
declare Integer[Integer] G_RoundScores;			// Number of rounds won by each clan

//UI
declare CUILayer LayerScores;
declare CUILayer LayerTeams;
declare CUILayer LayerPosition;
declare CUILayer LayerInformation;
declare CUILayer LayerMarkers;
declare Text[] G_PlayingPlayersLogins;			// Logins of all currently playing players
declare Text G_LongestLaserName;				// Name of longest laser shooter
declare Real G_LongestLaserDist;				// Distance of longest laser shot
declare Integer G_LastBigMessage;				// Time of LastBigMessage
declare Integer G_LastStatusMessage;			// Time of LastStatusMessage
declare Integer G_LastPoleUI;					// Time of LastPoleUI
declare CSmPlayer G_LastPlayerPoleUI;			// Last Player needs PoleUIReset
declare Boolean	G_Playing;

//Logs
declare Integer G_LogTime;





/*****************************************************
	EXTENSIONS
*****************************************************/
***StartServer***
***
MB_UseSectionRound = True;
InitGameSettings();
***

***StartMap***
***

Mode::Ladder_OpenMatch_All();
InitUI();
InitLayers();
InitValues();
PrepareMatch();
InitBases();
InitPoles();
if(!C_NoWarmUp){
	StartWarmup();
}
***

***StartRound***
***
PrepareRound();
CheckWarmup();
SetTeams();
SetRoles();
SetSpawnsAndPoles();
AnnounceAttackers();
StartPlay();
G_LogTime=StartTime+1000;
***

***OnNewPlayer***
***
EditUI(Player);
EditValues(Player);
***

***OnNewSpectator***
***
PrepareUIForSpectator(Spectator);
***

***PlayLoop***
***
if(Now>=G_LogTime && C_UsePlayLoopLogs){
	G_LogTime+=3000;
	//logs
	log("playloop logs");
}
if(C_UseBots){
	if(G_BlueBots!=S_BlueBots){
		G_BlueBots=S_BlueBots;
		Users_SetNbFakeUsers(G_BlueBots,G_RedBots);
	}else if(G_RedBots!=S_RedBots){
		G_RedBots=S_RedBots;
		Users_SetNbFakeUsers(G_BlueBots,G_RedBots);
	}
}
UpdateUI();
SpawnPlayers();
HandlePendingEvents();
ActivateGoal();
CheckForCapture();
RespawnDefender();
SetPoints();
***

***EndRound***
***
AttributePoints();
DisplayResults();
CheckMapEnd();
***

***EndMap***
***
EndMapUI();
***

***EndServer***
***
Clean();
***

/*****************************************************
	FUNCTIONS
*****************************************************/
//Other

/** Generate players list for the score table
 *
 *	@param	_Mode	The mode creating the list: 1 = Elite, 2 = Heroes
 *	@param	_Nb		Number of players in the list
 *	@param	_Scale	Width scale
 *
 *	@return	The players list Text
 */
Text CreatePlayersListBig(Integer _Mode, Integer _Nb, Real _Scale) {
	declare ML ="";
	declare PosX = 0.;
	declare PosY = 0.;
	declare Col = 2.;
	declare PlayersByCol = MathLib::NearestInteger(_Nb/Col);
	declare S = _Scale;
	declare K = 1;
	declare AvatarSize = 10.75;

	declare RocketHidden = 0;
	if (_Mode == 2) RocketHidden = 1;

	ML ^= """
<framemodel posn="0 0" id="Frame_PlayerLeft">
	<quad posn="0 0 2" sizen="{{{3*S}}} 11.5" image="file://Media/Manialinks/ShootMania/Elite/NotReady.dds" id="Quad_NotReady" />
	<quad posn="0 0 2" sizen="{{{3*S}}} 11.5" image="file://Media/Manialinks/ShootMania/Elite/Ready.dds" hidden="1" id="Quad_Ready" />
	<quad posn="{{{0*S}}} 0 1" sizen="{{{81.8*S}}} 11.5" bgcolor="a007" id="Quad_Attacker" hidden="1" />
	<quad posn="{{{0*S}}} 0 5" sizen="{{{81.8*S}}} 11.5" bgcolor="0009" id="Quad_Eliminated" hidden="1" />
	<quad posn="{{{(3*S)+6}}} {{{11.5/-2.}}} 2" sizen="{{{AvatarSize}}} {{{AvatarSize}}}" halign="center" valign="center" bgcolor="0003" opacity="0.9" id="Quad_Avatar" />
	<label posn="{{{17*S}}} -6.4 3" sizen="{{{45*S}}} 12" textsize="3" valign="bottom" id="Label_Name" />
	<label posn="{{{17*S}}} -10.4 3" sizen="{{{24*S}}} 5" textsize="1" valign="bottom" textemboss="1" id="Label_Rank" />
	<frame posn="{{{14.6*S}}} -2.7 4" id="Frame_Stars">
		<quad posn="0 0" sizen="2 2" valign="center" style="BgRaceScore2" substyle="Fame" id="Quad_Star_5" hidden="1" />
		<quad posn="0 -1.5" sizen="2 2" valign="center" style="BgRaceScore2" substyle="Fame" id="Quad_Star_4" hidden="1" />
		<quad posn="0 -3" sizen="2 2" valign="center" style="BgRaceScore2" substyle="Fame" id="Quad_Star_3" hidden="1" />
		<quad posn="0 -4.5" sizen="2 2" valign="center" style="BgRaceScore2" substyle="Fame" id="Quad_Star_2" hidden="1" />
		<quad posn="0 -6" sizen="2 2" valign="center" style="BgRaceScore2" substyle="Fame" id="Quad_Star_1" hidden="1" />
	</frame>
	<frame posn="{{{63*S}}} -10.4 2" id="Frame_LadderPoints" hidden="1">
		<quad posn="0 -2" sizen="{{{7*S}}} 7" halign="right" valign="bottom" style="Icons128x128_1" substyle="LadderPoints" />
		<label posn="-8 0" sizen="{{{12*S}}} 5" textsize="1" textcolor="bb8" halign="right" valign="bottom" id="Label_LadderPoints" />
	</frame>
	<frame posn="{{{70*S}}} -5.5 2" id="Frame_DefPointsSimple">
		<label posn="0 0" sizen="{{{5*S}}} 3" textsize="2" halign="left" valign="center" id="Label_DefPoints" />
		<quad posn="-0.5 -0.2" sizen="5 5" halign="right" valign="center" image="file://Media/Manialinks/ShootMania/Common/Rocket.dds" hidden="{{{RocketHidden}}}" />
	</frame>
	<frame posn="{{{70*S}}} 0 2" id="Frame_DefPointsDetailed" hidden="1">
		<label posn="0 -1.75" sizen="{{{5*S}}} 3" textsize="2" halign="left" valign="center" id="Label_DefLaser" />
		<label posn="0 -5.25" sizen="{{{5*S}}} 3" textsize="2" halign="left" valign="center" id="Label_DefRocket" />
		<label posn="0 -8.75" sizen="{{{5*S}}} 3" textsize="2" halign="left" valign="center" id="Label_DefNucleus" />
		<quad posn="-0.5 -1.95" sizen="3 3" halign="right" valign="center" image="file://Media/Manialinks/ShootMania/Common/Laser.dds" />
		<quad posn="-0.5 -5.45" sizen="3 3" halign="right" valign="center" image="file://Media/Manialinks/ShootMania/Common/Rocket.dds" />
		<quad posn="-0.5 -8.95" sizen="3 3" halign="right" valign="center" image="file://Media/Manialinks/ShootMania/Common/Nucleus.dds" />
	</frame>
	<label posn="{{{76*S}}} -5.5 3" sizen="{{{5*S}}} 5" textsize="5" halign="left" valign="center" id="Label_AtkPoints" />
</framemodel>
<framemodel posn="0 0" id="Frame_PlayerRight">
	<quad posn="0 0 2" sizen="{{{3*S}}} 11.5" halign="right" image="file://Media/Manialinks/ShootMania/Elite/NotReady.dds" id="Quad_NotReady" />
	<quad posn="0 0 2" sizen="{{{3*S}}} 11.5" halign="right" image="file://Media/Manialinks/ShootMania/Elite/Ready.dds" hidden="1" id="Quad_Ready" />
	<quad posn="{{{0*S}}} 0 1" sizen="{{{81.8*S}}} 11.5" bgcolor="a007" halign="right" id="Quad_Attacker" hidden="1" />
	<quad posn="{{{0*S}}} 0 5" sizen="{{{81.8*S}}} 11.5" bgcolor="0009" halign="right" id="Quad_Eliminated" hidden="1" />
	<quad posn="{{{(-3*S)-6}}} {{{11.5/-2.}}} 2" sizen="{{{AvatarSize}}} {{{AvatarSize}}}" halign="center" valign="center" bgcolor="0003" opacity="0.9" id="Quad_Avatar" />
	<label posn="{{{-17*S}}} -6.4 3" sizen="{{{45*S}}} 12" textsize="3" halign="right" valign="bottom" id="Label_Name" />
	<label posn="{{{-17*S}}} -10.4 3" sizen="{{{24*S}}} 5" textsize="1" halign="right" valign="bottom" textemboss="1" id="Label_Rank" />
	<frame posn="{{{-14.6*S}}} -2.7 4" id="Frame_Stars">
		<quad posn="0 0" sizen="2 2" halign="right" valign="center" style="BgRaceScore2" substyle="Fame" id="Quad_Star_5" hidden="1" />
		<quad posn="0 -1.5" sizen="2 2" halign="right" valign="center" style="BgRaceScore2" substyle="Fame" id="Quad_Star_4" hidden="1" />
		<quad posn="0 -3" sizen="2 2" halign="right" valign="center" style="BgRaceScore2" substyle="Fame" id="Quad_Star_3" hidden="1" />
		<quad posn="0 -4.5" sizen="2 2" halign="right" valign="center" style="BgRaceScore2" substyle="Fame" id="Quad_Star_2" hidden="1" />
		<quad posn="0 -6" sizen="2 2" halign="right" valign="center" style="BgRaceScore2" substyle="Fame" id="Quad_Star_1" hidden="1" />
	</frame>
	<frame posn="{{{-63*S}}} -10.4 2" id="Frame_LadderPoints" hidden="1">
		<quad posn="{{{13*S}}} -2" sizen="{{{7*S}}} 7" valign="bottom" style="Icons128x128_1" substyle="LadderPoints" />
		<label posn="{{{12*S}}} 0" sizen="{{{12*S}}} 5" textsize="1" textcolor="bb8" halign="right" valign="bottom" id="Label_LadderPoints" />
	</frame>
	<frame posn="{{{-70*S}}} -5.5 2" id="Frame_DefPointsSimple">
		<label posn="0 0" sizen="{{{5*S}}} 3" textsize="2" halign="right" valign="center" id="Label_DefPoints" />
		<quad posn="0.5 -0.2" sizen="5 5" halign="left" valign="center" image="file://Media/Manialinks/ShootMania/Common/Rocket2.dds" hidden="{{{RocketHidden}}}" />
	</frame>
	<frame posn="{{{-70*S}}} 0 2"id="Frame_DefPointsDetailed" hidden="1">
		<label posn="0 -1.75" sizen="{{{5*S}}} 3" textsize="2" halign="right" valign="center" id="Label_DefLaser" />
		<label posn="0 -5.25" sizen="{{{5*S}}} 3" textsize="2" halign="right" valign="center" id="Label_DefRocket" />
		<label posn="0 -8.75" sizen="{{{5*S}}} 3" textsize="2" halign="right" valign="center" id="Label_DefNucleus" />
		<quad posn="0.5 -1.95" sizen="3 3" halign="left" valign="center" image="file://Media/Manialinks/ShootMania/Common/Laser.dds" />
		<quad posn="0.5 -5.45" sizen="3 3" halign="left" valign="center" image="file://Media/Manialinks/ShootMania/Common/Rocket.dds" />
		<quad posn="0.5 -8.95" sizen="3 3" halign="left" valign="center" image="file://Media/Manialinks/ShootMania/Common/Nucleus.dds" />
	</frame>
	<label posn="{{{-76*S}}} -5.5 3" sizen="{{{5*S}}} 5" textsize="5" halign="right" valign="center" id="Label_AtkPoints" />
</framemodel>
""";
	declare BgColor = C_UI_Colors["BG"];
	if (_Mode == 2) BgColor = "667c";

	for (J, 1, 2) {
		for (I, 1, PlayersByCol) {
			if (J % 2 == 1) {
				ML ^= """
<frame posn="{{{PosX}}} {{{PosY}}}">
	<quad posn="0 0 -6" sizen="{{{81.8*S}}} 11.5" bgcolor="{{{BgColor}}}" />
	<frameinstance modelid="Frame_PlayerLeft" id="Frame_Player_{{{K}}}" />
</frame>
""";
			} else {
				ML ^= """
<frame posn="{{{PosX+(164*S/2.)}}} {{{PosY}}}">
	<quad posn="0 0 -6" sizen="{{{81.8*S}}} 11.5" bgcolor="{{{BgColor}}}" halign="right" />
	<frameinstance modelid="Frame_PlayerRight" id="Frame_Player_{{{K}}}" />
</frame>
""";
			}
			PosY -= 11.9;
			K += 1;
		}
		PosX += 164*S/2.;
		PosY = 0.;
	}

	return ML;
}

/** Create the score table manialink string.
 * 
 * @return		The manialink string
 */
Text CreateLayerScoresTable() {
declare CW = 1.;
declare SW = 1.;

declare Team1Color = """{{{Teams[0].ColorPrimary.X}}} {{{Teams[0].ColorPrimary.Y}}} {{{Teams[0].ColorPrimary.Z}}}""";
declare Team2Color = """{{{Teams[1].ColorPrimary.X}}} {{{Teams[1].ColorPrimary.Y}}} {{{Teams[1].ColorPrimary.Z}}}""";
return "";
return """
<quad posn="0 -0.5 -1" sizen="237 90" halign="center" valign="center" image="file://Media/Manialinks/ShootMania/Elite/interface_elite_bg.dds" />
<quad posn="-73.2 11 6" sizen="29 44.3" halign="center" valign="center" image="file://Media/Manialinks/ShootMania/Elite/interface_elite_left.dds" colorize="{{{Team1Color}}}" />
<quad posn=" 73.2 11 6" sizen="29 44.3" halign="center" valign="center" image="file://Media/Manialinks/ShootMania/Elite/interface_elite_right.dds" colorize="{{{Team2Color}}}" />

<!--<quad posn="-150 90" sizen="{{{50*CW}}} 20" halign="left" valign="top" style="TitleLogos" substyle="Title"/>-->

<!-- **************** Scores table **************** -->
<frame posn="0 34" id ="Frame_ScoresTable">
	<!-- **************** Center panel **************** -->
	<frame posn="0 0">		
		<!-- **************** VS **************** -->
		<frame posn="0 -11.7" id="Frame_VS">
			<quad posn="-7 -2.5" sizen="15 15" halign="right" valign="bottom" style="Emblems" substyle="#1" />
			<quad posn="7 -2.5" sizen="15 15" valign="bottom" style="Emblems" substyle="#2" />
			<label posn="-46 1.5" sizen="46 5" textsize="4" halign="center" valign="bottom" scale="0.95" opacity="0.88" textemboss="1" id="Label_NameTeam1" />
			<label posn=" 46 1.5" sizen="46 5" textsize="4" halign="center" valign="bottom" scale="0.95" opacity="0.88" textemboss="1" id="Label_NameTeam2" />
		</frame>
		<!-- **************** Players Ranking **************** -->
		<frame posn="{{{-164*CW/2.}}} -16" id="Frame_Ranking">
			{{{CreatePlayersListBig(1, C_PlayerNeeded, CW)}}}
		</frame>
	</frame>	
	<!-- **************** Bottom panels **************** -->
	<frame posn="{{{-164*CW/2.}}} -47">
		<!-- **************** Laser stats **************** -->
		<quad posn="{{{1*SW}}} -8.2" sizen="4 4" halign="left" valign="center" image="file://Media/Manialinks/ShootMania/Common/Laser.dds" />
		<label posn="{{{6*SW}}} -8" sizen="{{{75*SW}}} 6" textsize="2" textcolor="{{{C_UI_Colors["Text"]}}}" valign="center" textemboss="1" text="{{{TextLib::Compose(_("Longest Laser: %1 by %2"), "-", "-")}}}" id="Label_LongestLaser" />
		<!-- **************** Server info **************** -->
		<label posn="{{{158*CW}}} -8" sizen="{{{75*SW}}} 5" textsize="2" textcolor="{{{C_UI_Colors["Text"]}}}" halign="right" valign="center" textemboss="1" text="{{{TextLib::Compose("%1: $<%2$>", _("Server"), "-")}}}" id="Label_ServerName" />
		<quad posn="{{{163*SW}}} -8.2" sizen="4 4" halign="right" valign="center" image="file://Media/Manialinks/ShootMania/Common/Home.dds" />
		<!-- **************** Game info **************** -->
		<quad posn="{{{0.7*SW}}} -13.7" sizen="5 5" halign="left" valign="center" style="UIConstructionSimple_Buttons" substyle="Tools" />
		<label posn="{{{6*SW}}} -13.5" sizen="{{{75*SW}}} 6" textsize="2" textcolor="{{{C_UI_Colors["Text"]}}}" valign="center" textemboss="1" text="{{{TextLib::Compose(_("Points limit: %1 | Points to win: %2"), "6", "8")}}}" id="Label_GameInfo" />
		<label posn="{{{158*CW}}} -13.5" sizen="{{{75*SW}}} 5" textsize="2" textcolor="{{{C_UI_Colors["Text"]}}}" halign="right" valign="center" textemboss="1" text="{{{TextLib::Compose(_("Turns won: %1 - %2 | Eliminations: %3 - %4"), "0", "0","0", "0")}}}" id="Label_GoalAverage" />
		<quad posn="{{{163*SW}}} -13.7" sizen="4 4" halign="right" valign="center" image="file://Media/Manialinks/ShootMania/Common/Score.dds" />
	</frame>
</frame>
<script><!--
#Include "TextLib" as TextLib

declare CMlLabel	Label_NameTeam1;
declare CMlLabel 	Label_NameTeam2;
declare CMlFrame	Frame_Ranking;
declare CMlLabel	Label_LongestLaser;
declare CMlLabel	Label_ServerName;
declare CMlLabel	Label_GameInfo;
declare CMlLabel	Label_GoalAverage;

Void UpdatePlayersList(
	Integer				_AttackerKey, 
	Text[Integer]		_Logins, 
	Text[Integer]		_Names, 
	Text[Integer]		_Zones,
	Integer[Integer]	_Ranks,
	Real[Integer]		_LadderPoints,
	Boolean[Integer]	_Ready,
	Integer[Integer]	_DefPoints, 
	Integer[Integer]	_AtkPoints,
	Integer				_Mode,
	Integer[Integer][Integer] _DefHit,
	Integer[Integer]	_Fames,
	Ident[Integer]		_PlayersIds
) {	
	for (I, 1, {{{C_PlayerNeeded*2}}}) {
		declare Frame_Player	<=> (Frame_Ranking.GetFirstChild("Frame_Player_"^I) as CMlFrame);

		if (_Logins.existskey(I)) {
			declare Quad_NotReady			<=> (Frame_Player.GetFirstChild("Quad_NotReady")			as CMlQuad);
			declare Quad_Ready				<=> (Frame_Player.GetFirstChild("Quad_Ready")				as CMlQuad);
			declare Quad_Avatar 			<=> (Frame_Player.GetFirstChild("Quad_Avatar")				as CMlQuad);
			declare Quad_Eliminated			<=> (Frame_Player.GetFirstChild("Quad_Eliminated")			as CMlQuad);
			declare Label_Name				<=> (Frame_Player.GetFirstChild("Label_Name")				as CMlLabel);
			declare Label_Rank				<=> (Frame_Player.GetFirstChild("Label_Rank")				as CMlLabel);
			declare Frame_Stars				<=> (Frame_Player.GetFirstChild("Frame_Stars")				as CMlFrame);
			declare Label_DefPoints			<=> (Frame_Player.GetFirstChild("Label_DefPoints")			as CMlLabel);
			declare Label_AtkPoints			<=> (Frame_Player.GetFirstChild("Label_AtkPoints")			as CMlLabel);
			declare Quad_Attacker			<=> (Frame_Player.GetFirstChild("Quad_Attacker")			as CMlQuad);
			declare Frame_LadderPoints		<=> (Frame_Player.GetFirstChild("Frame_LadderPoints")		as CMlFrame);
			declare Label_LadderPoints		<=> (Frame_Player.GetFirstChild("Label_LadderPoints")		as CMlLabel);
			declare Frame_DefPointsSimple	<=> (Frame_Player.GetFirstChild("Frame_DefPointsSimple")	as CMlFrame);
			declare Frame_DefPointsDetailed	<=> (Frame_Player.GetFirstChild("Frame_DefPointsDetailed")	as CMlFrame);
			declare Label_DefLaser			<=> (Frame_DefPointsDetailed.GetFirstChild("Label_DefLaser")	as CMlLabel);
			declare Label_DefRocket			<=> (Frame_DefPointsDetailed.GetFirstChild("Label_DefRocket")	as CMlLabel);
			declare Label_DefNucleus		<=> (Frame_DefPointsDetailed.GetFirstChild("Label_DefNucleus")	as CMlLabel);

			declare Side = 1;
			if (Label_Name.PosnX < 0) Side = -1;

			Frame_Player.Show();
			// Ready state
			if (_Mode == {{{C_SequenceWarmUp}}}) {
				Quad_Avatar.PosnX = {{{6 + (3*CW)}}} * Side;
				Label_Name.PosnX = {{{17*CW}}} * Side;
				Label_Rank.PosnX = {{{18*CW}}} * Side;
				Frame_Stars.PosnX = {{{14.6*CW}}} * Side;
				if (_Ready.existskey(I)) {
					if (_Ready[I]) {
						Quad_Ready.Show();
						Quad_NotReady.Hide();
					} else {
						Quad_Ready.Hide();
						Quad_NotReady.Show();
					}
				} else {
					Quad_Ready.Hide();
					Quad_NotReady.Show();
				}
			} else {
				Quad_Avatar.PosnX = {{{6 + (0*CW)}}} * Side;
				Label_Name.PosnX = {{{14*CW}}} * Side;
				Label_Rank.PosnX = {{{15*CW}}} * Side;
				Frame_Stars.PosnX = {{{11.6*CW}}} * Side;
				Quad_Ready.Hide();
				Quad_NotReady.Hide();
			}
			// Avatar
			if (_Logins.existskey(I) && _Names.existskey(I)) {
				Quad_Avatar.ChangeImageUrl("file://Avatars/"^_Logins[I]^"/Default");
			} else {
				Quad_Avatar.ChangeImageUrl("");
			}
			// Status
			/*if (UI.UISequence == CUIConfig::EUISequence::Playing && _PlayersIds.existskey(I)) {
				if (Players.existskey(_PlayersIds[I])) {
					if (Players[_PlayersIds[I]].SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {
						Quad_Eliminated.Show();
					} else {
						Quad_Eliminated.Hide();
					}
				} else {
					Quad_Eliminated.Hide();
				}
			} else {
				Quad_Eliminated.Hide();
			}*/
			// Name
			if (_Names.existskey(I)) {
				Label_Name.SetText("$s"^_Names[I]);
			} else {
				Label_Name.SetText("$s-");
			}
			// Rank
			if (_Ranks.existskey(I) && _Ranks[I] > 0 && _Zones.existskey(I)) {
				Label_Rank.SetText(TextLib::Compose("%1: %2", _Zones[I], TextLib::ToText(_Ranks[I])));
			} else {
				Label_Rank.SetText(TextLib::Compose("%1: %2", _("Other"), "-"));
			}
			// Stars Fames
			if (_Fames.existskey(I)) {
				declare Fame = _Fames[I];
				if (Fame > 0 && Fame <= 5) {
					declare Quad_Star_1 <=> (Frame_Stars.GetFirstChild("Quad_Star_1") as CMlQuad);
					declare Quad_Star_2 <=> (Frame_Stars.GetFirstChild("Quad_Star_2") as CMlQuad);
					declare Quad_Star_3 <=> (Frame_Stars.GetFirstChild("Quad_Star_3") as CMlQuad);
					declare Quad_Star_4 <=> (Frame_Stars.GetFirstChild("Quad_Star_4") as CMlQuad);
					declare Quad_Star_5 <=> (Frame_Stars.GetFirstChild("Quad_Star_5") as CMlQuad);
					Frame_Stars.Show();
					Quad_Star_1.Hide();
					Quad_Star_2.Hide();
					Quad_Star_3.Hide();
					Quad_Star_4.Hide();
					Quad_Star_5.Hide();

					if (Fame >= 1) Quad_Star_1.Show();
					if (Fame >= 2) Quad_Star_2.Show();
					if (Fame >= 3) Quad_Star_3.Show();
					if (Fame >= 4) Quad_Star_4.Show();
					if (Fame >= 5) Quad_Star_5.Show();
				} else {
					Frame_Stars.Hide();
				}
			} else {
				Frame_Stars.Hide();
			}
			// Ladder points
			if (_Mode == {{{C_SequencePodium}}} && _LadderPoints.existskey(I) && _LadderPoints[I] >= 0) {
				declare LadderPointsExplode = TextLib::Split(".", TextLib::ToText(_LadderPoints[I]));
				declare LadderPoints = "0.0";
				if (LadderPointsExplode.existskey(0)) LadderPoints = LadderPointsExplode[0];
				if (LadderPointsExplode.existskey(1)) LadderPoints ^= "."^TextLib::SubString(LadderPointsExplode[1], 0, 2);

				Frame_LadderPoints.Show();
				Label_LadderPoints.SetText("$s$bb8+"^LadderPoints);
			} else {
				Frame_LadderPoints.Hide();
			}
			// DefPoints
			if(_DefHit[I].count>0){
			if (_DefHit.existskey(I) && _DefHit[I][1] >= 0 && _DefHit[I][3] >= 0) {
				Frame_DefPointsSimple.Hide();
				Frame_DefPointsDetailed.Show();
				if (_DefPoints.existskey(I)) {
					Label_DefLaser.SetText("$s"^_DefHit[I][1]);
					Label_DefRocket.SetText("$s"^_DefHit[I][2]);
					Label_DefNucleus.SetText("$s"^_DefHit[I][3]);
				} else {
					Label_DefLaser.SetText("$s0");
					Label_DefRocket.SetText("$s0");
					Label_DefNucleus.SetText("$s0");
				}
			} else {
				Frame_DefPointsSimple.Show();
				Frame_DefPointsDetailed.Hide();
				if (_DefPoints.existskey(I)) {
					Label_DefPoints.SetText("$s"^_DefPoints[I]);
				} else {
					Label_DefPoints.SetText("$s0");
				}
			}
			}
			// AtkPoints
			if (_AtkPoints.existskey(I)) {
				Label_AtkPoints.SetText("$s"^_AtkPoints[I]);
			} else {
				Label_AtkPoints.SetText("$s0");
			}
			// Attacker
			if (I == _AttackerKey && _Mode == {{{C_SequencePlaying}}}) {
				Quad_Attacker.Show();
			} else {
				Quad_Attacker.Hide();
			}
		} else {
			Frame_Player.Hide();
		}
	}
}

Void UpdateStats(
	Text[Integer]		_Names,
	Real[Integer]		_LaserLongest,
	Integer[Integer]	_LaserHit,
	Integer[Integer]	_LaserShot
) {	
	declare LaserLongest = Real[Integer];
	foreach (Key => Distance in _LaserLongest) {
		if (Distance > 0.) LaserLongest[Key] = Distance * -1.;
	}
	LaserLongest = LaserLongest.sort();
	declare LaserAccuracy = Real[Integer];

	foreach (Key => Nb in _LaserShot) {
		if (Nb > 0 && _LaserHit.existskey(Key) && _LaserHit[Key] > 0) {
			LaserAccuracy[Key] = ((_LaserHit[Key] * 1.) / (Nb * 1.)) * -100.;
		}
	}
	LaserAccuracy = LaserAccuracy.sort();

	declare Longest = "-";
	declare LongestName = "-";
	declare Accuracy = "-";
	declare AccuracyName = "-";

	foreach (Key => Distance in LaserLongest) {
		Longest = TextLib::SubString(TextLib::ToText(Distance*-1.), 0, 5)^"m";
		if (_Names.existskey(Key)) LongestName = "$<"^_Names[Key]^"$>";
		break;
	}

	foreach (Key => Percentage in LaserAccuracy) {
		Accuracy = _LaserHit[Key]^"/"^_LaserShot[Key]^" ("^TextLib::SubString(TextLib::ToText(Percentage*-1.), 0, 5)^"%)";
		if (_Names.existskey(Key)) AccuracyName = _Names[Key];
		break;
	}

	Label_LongestLaser.SetText(TextLib::Compose(_("Longest Laser: %1 by %2"), Longest, LongestName));
}

Void UpdateGameInfo(
	Integer _PointsLimit,
	Integer _PointsToWin,
	Integer[Integer] _Turns,
	Integer[Integer] _Eliminations
) {
	Label_GameInfo.SetText(TextLib::Compose(_("Points limit: %1 | Points to win: %2"), TextLib::ToText(_PointsLimit), TextLib::ToText(_PointsToWin)));

	if (_Eliminations.existskey(1) && _Eliminations.existskey(2)) {
		Label_GoalAverage.SetText(TextLib::Compose(_("Turns won: %1 - %2 | Eliminations: %3 - %4"), TextLib::ToText(_Turns[1]), TextLib::ToText(_Turns[2]), TextLib::ToText(_Eliminations[1]), TextLib::ToText(_Eliminations[2])));
	} else {
		Label_GoalAverage.SetText(TextLib::Compose(_("Turns won: %1 - %2"), TextLib::ToText(_Turns[1]), TextLib::ToText(_Turns[2])));
	}
}

Void UpdatePlayersStatus(Boolean _Forced) {
	declare netread Text[Integer] Net_LayerST_Logins for UI;

	foreach (Player in Players) {
		declare PrevSpawnStatus for Player = CSmPlayer::ESpawnStatus::Spawned;
		if (PrevSpawnStatus != Player.SpawnStatus || _Forced) {
			PrevSpawnStatus = Player.SpawnStatus;
			if (!Net_LayerST_Logins.exists(Player.Login)) continue;

			declare Frame_Player <=> (Frame_Ranking.GetFirstChild("Frame_Player_"^Net_LayerST_Logins.keyof(Player.Login)) as CMlFrame);
			if (Frame_Player == Null) continue;

			declare Quad_Eliminated <=> (Frame_Player.GetFirstChild("Quad_Eliminated") as CMlQuad);
			declare netread Integer Net_LayerST_Mode for UI;

			if (Net_LayerST_Mode == {{{C_SequencePlaying}}} && UI.UISequence == CUIConfig::EUISequence::Playing) {
				if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {
					Quad_Eliminated.Show();
				} else {
					Quad_Eliminated.Hide();
				}
			} else {
				Quad_Eliminated.Hide();
			}
		}
	}
}

main() {
	Label_NameTeam1			<=> (Page.GetFirstChild("Label_NameTeam1")		as CMlLabel);
	Label_NameTeam2			<=> (Page.GetFirstChild("Label_NameTeam2")		as CMlLabel);
	Frame_Ranking			<=> (Page.GetFirstChild("Frame_Ranking")		as CMlFrame);
	Label_LongestLaser		<=> (Page.GetFirstChild("Label_LongestLaser")	as CMlLabel);
	Label_ServerName		<=> (Page.GetFirstChild("Label_ServerName")		as CMlLabel);
	Label_GameInfo			<=> (Page.GetFirstChild("Label_GameInfo")		as CMlLabel);
	Label_GoalAverage		<=> (Page.GetFirstChild("Label_GoalAverage")	as CMlLabel);

	declare netread Integer				Net_LayerST_Update			for UI;
	declare netread Integer				Net_LayerST_AttackerKey		for UI;
	declare netread Text[Integer]		Net_LayerST_Logins			for UI;
	declare netread Integer[Integer]	Net_LayerST_AtkPoints		for UI;
	declare netread Integer[Integer]	Net_LayerST_DefPoints		for UI;
	declare netread Real[Integer]		Net_LayerST_LaserLongest	for UI;
	declare netread Integer[Integer]	Net_LayerST_LaserShot		for UI;
	declare netread	Integer[Integer]	Net_LayerST_LaserHit		for UI;
	declare netread Integer				Net_LayerST_PointsLimit		for UI;
	declare netread Integer				Net_LayerST_PointsToWin		for UI;
	declare netread Integer[Integer]	Net_LayerST_Turns			for UI;
	declare netread Integer[Integer]	Net_LayerST_Eliminations	for UI;
	declare netread Boolean[Integer]	Net_LayerST_Ready			for UI;
	declare netread Integer				Net_LayerST_Mode			for UI;
	declare netread Integer[Integer][Integer] Net_LayerST_DefHit	for UI;

	declare Text[Integer]		Logins;
	declare Text[Integer]		Names;
	declare Integer[Integer]	LadderRanks;
	declare Text[Integer]		Zones;
	declare Integer				Order;
	declare Real[Integer]		LadderPoints;
	declare Integer[Integer]	Fames;
	declare Ident[Integer]		PlayersIds;

	declare LastUpdate = Net_LayerST_Update;
	declare PrevUISequence = CUIConfig::EUISequence::None;
	declare PrevServerName = "";

	while (True) {
		yield;

		if (InputPlayer == Null) continue;
		if (!PageIsVisible) continue;

		if (PrevServerName != CurrentServerName) {
			PrevServerName = CurrentServerName;
			Label_ServerName.SetText(TextLib::Compose("%1: $<%2$>", _("Server"), CurrentServerName));
		}

		if (LastUpdate != Net_LayerST_Update) {
			LastUpdate = Net_LayerST_Update;

			UpdatePlayersStatus(True);

			if (Teams[0].ColorizedName == "$<$00fBlue$>") Label_NameTeam1.SetText("$<$fffBlue$>");
			else Label_NameTeam1.SetText(Teams[0].ColorizedName);
			if (Teams[1].ColorizedName == "$<$f00Red$>") Label_NameTeam2.SetText("$<$fffRed$>");
			else Label_NameTeam2.SetText(Teams[1].ColorizedName);

			Logins = Net_LayerST_Logins;

			if (Net_LayerST_AttackerKey <= 0) Order = -1;
			else if (Net_LayerST_AttackerKey <= 3) Order = Net_LayerST_AttackerKey;
			else Order = Net_LayerST_AttackerKey - 3;

			Names.clear();
			LadderRanks.clear();
			foreach (Score in Scores) {
				if (Logins.exists(Score.User.Login)) {
					declare Key = Logins.keyof(Score.User.Login);
					Names[Key] = Score.User.Name;
					LadderRanks[Key] = Score.User.LadderRank;
					LadderPoints[Key] = Score.LadderScore;
					Fames[Key] = Score.User.FameStars;

					declare ZonePath = "";
					if (Score.User.ZonePath != "") {
						declare ExplodeZonePath = TextLib::Split("|", Score.User.ZonePath);
						if (ExplodeZonePath.existskey(1)) ZonePath = ExplodeZonePath[1];
					}
					Zones[Key] = ZonePath;
				}
			}
			/*foreach (Player in Players) {
				if (Logins.exists(Player.Login)) {
					declare Key = Logins.keyof(Player.Login);
					PlayersIds[Key] = Player.Id;
				}
			}*/

			UpdatePlayersList(
				Net_LayerST_AttackerKey, 
				Logins, 
				Names, 
				Zones,
				LadderRanks,
				LadderPoints,
				Net_LayerST_Ready, 
				Net_LayerST_DefPoints, 
				Net_LayerST_AtkPoints,
				Net_LayerST_Mode,
				Net_LayerST_DefHit,
				Fames,
				PlayersIds
			);

			UpdateStats(
				Names,
				Net_LayerST_LaserLongest,
				Net_LayerST_LaserHit,
				Net_LayerST_LaserShot
			);

			UpdateGameInfo(
				Net_LayerST_PointsLimit,
				Net_LayerST_PointsToWin,
				Net_LayerST_Turns,
				Net_LayerST_Eliminations
			);
		}

		if (PrevUISequence != UI.UISequence) {
			PrevUISequence = UI.UISequence;

			if (UI.UISequence != CUIConfig::EUISequence::Playing) {
				for (I, 1, {{{C_PlayerNeeded*2}}}) {
					declare Frame_Player	<=> (Frame_Ranking.GetFirstChild("Frame_Player_"^I)	as CMlFrame);
					declare Quad_Eliminated <=> (Frame_Player.GetFirstChild("Quad_Eliminated") as CMlQuad);
					Quad_Eliminated.Hide();
				}
			}
		}

		if (UI.UISequence == CUIConfig::EUISequence::Playing) UpdatePlayersStatus(False);
	}
}
--></script>
""";
}
/** Update the score table manialink string.
 *
 *	@param	_Mode	Type of display for the scores table (warm-up, playing, ...)
 * 
 *	@return		The manialink string
 */
Void UpdateLayerScoresTable(Integer _Mode) {
declare Logins			= Text[Integer];
declare Attacker1Key		= -1;
declare Attacker2Key		= -1;
declare AtkPoints		= Integer[Integer];
declare DefPoints		= Integer[Integer];
declare LasersLongest	= Real[Integer];
declare LasersHit		= Integer[Integer];
declare LasersShot		= Integer[Integer];
declare Eliminations	= [0 => 0];
declare ReadyState		= Boolean[Integer];
declare DetailedDefPoints = Integer[Integer][Integer];

for (I, 1, 2) {
	declare J = 1;
	G_MapOrder[I] = G_MapOrder[I].sort();
	foreach (Id => Order in G_MapOrder[I]) {
		if (Players.existskey(Id)) {
			declare Key = J+((I-1)*3);
			declare Player <=> Players[Id];
			Logins[Key] = Player.Login;
			if (Id == G_Team1AttackingPlayer) Attacker1Key = Key;
			if (Id == G_Team2AttackingPlayer) Attacker2Key = Key;
			if (Player.Score != Null) {
				declare NbHit for Player.Score = 0;
				declare LaserLongest for Player.Score = 0.;
				declare LaserHit for Player.Score = 0;
				declare LaserShot for Player.Score = 0;
				declare DefHit for Player.Score = G_InitDefHit;
				AtkPoints[Key] = Player.Score.Points;
				DefPoints[Key] = NbHit;
				LasersLongest[Key] = LaserLongest;
				LasersHit[Key] = LaserHit;
				LasersShot[Key] = LaserShot;
				DetailedDefPoints[Key] = DefHit;
			}
			ReadyState[Key] = WarmUp::IsReady(Player);
		}
		J += 1;
	}
}

//if (G_TieBreak) Eliminations = [1 => G_TieBreakDefElim[1], 2 => G_TieBreakDefElim[2]];

declare PlayersAndSpectators = CSmPlayer[];
foreach (Player in Players) PlayersAndSpectators.add(Player);
foreach (Spectator in Spectators) PlayersAndSpectators.add(Spectator);
foreach (Player in PlayersAndSpectators) {
	declare UI <=> UIManager.GetUI(Player);
	if (UI == Null) continue;

	declare netwrite Integer			Net_LayerST_Update			for UI;
	declare netwrite Integer			Net_LayerST_Attacker1Key	for UI;
	declare netwrite Integer			Net_LayerST_Attacker2Key	for UI;
	declare netwrite Text[Integer]		Net_LayerST_Logins			for UI;
	declare netwrite Integer[Integer]	Net_LayerST_AtkPoints		for UI;
	declare netwrite Integer[Integer]	Net_LayerST_DefPoints		for UI;
	declare netwrite Real[Integer]		Net_LayerST_LaserLongest	for UI;
	declare netwrite Integer[Integer]	Net_LayerST_LaserShot		for UI;
	declare netwrite Integer[Integer]	Net_LayerST_LaserHit		for UI;
	declare netwrite Integer			Net_LayerST_PointsLimit		for UI;
	declare netwrite Integer			Net_LayerST_PointsToWin		for UI;
	//declare netwrite Integer[Integer]	Net_LayerST_Turns			for UI;
	declare netwrite Integer[Integer]	Net_LayerST_Eliminations	for UI;
	declare netwrite Boolean[Integer]	Net_LayerST_Ready			for UI;
	declare netwrite Integer			Net_LayerST_Mode			for UI;
	declare netwrite Integer[Integer][Integer] Net_LayerST_DefHit	for UI;

	Net_LayerST_Update			= Now;
	Net_LayerST_Attacker1Key	= Attacker1Key;
	Net_LayerST_Attacker2Key	= Attacker2Key;
	Net_LayerST_Logins			= Logins;
	Net_LayerST_AtkPoints		= AtkPoints;
	Net_LayerST_DefPoints		= DefPoints;
	Net_LayerST_LaserLongest	= LasersLongest;
	Net_LayerST_LaserShot		= LasersShot;
	Net_LayerST_LaserHit		= LasersHit;
	Net_LayerST_PointsLimit		= S_PointLimitDecisiveRound;
	Net_LayerST_PointsToWin		= S_PointLimitToWin;
	//Net_LayerST_Turns			= [1 => G_MatchPoints[1], 2 => G_MatchPoints[2]];
	Net_LayerST_Eliminations	= Eliminations;
	Net_LayerST_Ready			= ReadyState;
	Net_LayerST_Mode			= _Mode;
	Net_LayerST_DefHit			= DetailedDefPoints;
}
}
// Spawn a Player
Void SpawnThePlayer(CSmPlayer Player){
	declare CSmBlockSpawn Spawn;
	foreach(BlockSpawn in BlockSpawns){
		if(BlockSpawn.Base.Clan==Player.CurrentClan){
			Spawn = BlockSpawn;
		}
	}
	
	This.SetPlayerAmmoMax(Player, CSmMode::EWeapon::Nucleus, 1);
	This.SetPlayerAmmoMax(Player, CSmMode::EWeapon::Laser, 1);
	This.SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, 4);
	This.SetPlayerAmmoMax(Player, CSmMode::EWeapon::Arrow, 1);
	
	if (Player.Id == G_Team1AttackingPlayer || Player.Id == G_Team2AttackingPlayer){
		This.SetPlayerWeapon(Player, CSmMode::EWeapon::Laser, False);
		Player.AmmoGain = C_AttackerAmmoGain;
		if(Player.Id == G_Team1AttackingPlayer){
			Player.ArmorMax = G_Team2DefenderPlayers.count*C_AttackerArmorMultiplier*100;
		}else{
			Player.ArmorMax = G_Team1DefenderPlayers.count*C_AttackerArmorMultiplier*100;
		}
		
		SM::SpawnPlayer(Player, Player.CurrentClan, Spawn, StartTime);
		//SpawnPlayer(Player, Player.CurrentClan, Player.ArmorMax, Spawn, StartTime);
		return;
	}else{
		This.SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, True);
		Player.AmmoGain = C_DefenderAmmoGain;
		Player.ArmorMax = C_DefenderArmor*100;
		SM::SpawnPlayer(Player, Player.CurrentClan, Spawn, StartTime);
		//SpawnPlayer(Player, Player.CurrentClan, Player.ArmorMax, Spawn, StartTime);
		return;
	}
}
/** Spawns all the players.
 * 
 * @param _Phase		0 playing time, 1 warmup KotM, 2 warmup classic/free, 3 waiting time 
 */
Void SpawnThemAll(Integer _Phase) {
	// Get spawns
	declare CSmBlockSpawn BlockSpawn1;
	declare CSmBlockSpawn BlockSpawn2;
	foreach (Spawn in BlockSpawns) {
		if(Spawn.Order==1){
			BlockSpawn1 = Spawn;
		}else if(Spawn.Order==2){
			BlockSpawn2 = Spawn;
		}
	}
	

	// WarmUp classic/free || Waiting time
	if (_Phase == 2 || _Phase == 3) {
		foreach (Player in Players) {
			declare WarmUpSide for Player = True;
			if (Player.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) continue;

			SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, 4);
			SetPlayerAmmoMax(Player, CSmMode::EWeapon::Laser, 1);
			SetPlayerAmmoMax(Player, CSmMode::EWeapon::Nucleus, 1);
			Player.ArmorMax	= 2;
			if (WarmUpSide) {
				Player.AmmoGain	= 1. * C_AttackerAmmoGain;
				Player.StaminaMax = 1.;
				Player.StaminaGain = 1.;

				SetPlayerWeapon(Player, CSmMode::EWeapon::Laser, False);
				SM::SpawnPlayer(Player, Player.RequestedClan, Player.ArmorMax, BlockSpawn1, Now);
				SetPlayerAmmo(Player, CSmMode::EWeapon::Nucleus, 1);
			} else {
				Player.AmmoGain	= 1. * C_DefenderAmmoGain;
				Player.StaminaMax = 1. * C_DefStaminaMaxMultiplier;
				Player.StaminaGain = 1. * C_DefStaminaMaxMultiplier;
				SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, True); 
				SM::SpawnPlayer(Player, Player.RequestedClan, Player.ArmorMax, BlockSpawn2, Now);
				SetPlayerAmmo(Player, CSmMode::EWeapon::Nucleus, 1);
			}
			Player.IsHighlighted = True;
			WarmUpSide = !WarmUpSide;
		}
	}
	// Playing time
	else {
		foreach(Player in Players){
			SpawnThePlayer(Player);
		}
	} 	
}
/** Can we start the turn or not?
 *
 * @param _MinimumCriteria	True: At least 1 def and 1 atk ready | False: all players with 1 atk and 1 def ready
 *
 * @return		True if we can start the turn, false otherwise
 */
Integer CanStartTurn(Boolean _MinimumCriteria) {
	declare NbAtk = 0;
	declare NbAtkReady = 0;
	declare NbDef = 0;
	declare NbDefReady = 0;
	declare CanStart = False;

	// Can't start round if ...
	foreach (ClanNumber => ClanOrder in WarmUp::GetOrder()) {
		// ... a slot is empty
		if (!S_FreeMode  && ClanOrder.count != C_PlayerNeeded/2) {
			return -1;
		} else if (S_FreeMode && ClanOrder.count < 2) {
			return -3;
		}
		foreach (PlayerId => PlayerOrder in ClanOrder) {
			// ... the player in the slot doesn't exist
			if (!Players.existskey(PlayerId)) {
				return -2;
			}
			// ... the player in the slot changed team
			else if (Players[PlayerId].RequestedClan != ClanNumber) {
				return -7;
			}
			// In other cases, check if the player is ready
			else {
				declare IsPlayerReady = False;
				declare Player <=> Players[PlayerId];

				// Bot default to ready state
				if (Player.IsFakePlayer) {
					IsPlayerReady = True;
				} else {
					IsPlayerReady = WarmUp::IsReady(Player);
				}
				declare Clan = 0;
				Clan = Player.RequestedClan;
				if (Clan == 1) {
					if (IsPlayerReady) NbAtkReady += 1;
					NbAtk += 1;
				} else if (Clan == 2) {
					if (IsPlayerReady) NbDefReady += 1;
					NbDef += 1;
				}
			}
		}
	}

	// If we don't want to use the warmup, return true when there's at least one player in each clan
	if (S_WarmUpDuration <= 0) {
		return 1;
	} else if (_MinimumCriteria) {
		if ((NbAtkReady >= 1) && (NbDefReady >= 1)) return 1;
		else return -4;
	} else {
		if (S_FreeMode) {
			if((NbAtkReady == NbAtk) && (NbDefReady == NbDef)) return 1;
			else return -5;
		} else {
			if((NbAtkReady >= C_PlayerNeeded/2) && (NbDefReady >= C_PlayerNeeded/2)) return 1;
			else return -5;
		}
	}

	return -6;
}
// ---------------------------------- //
/// Warmup.
Void DoWarmUp() {
	// Waiting that the UI receives initial data
	MB_Sleep(1000);

	if (MB_UseScriptCallbacks) XmlRpc.SendCallback("BeginWarmup", Json::Enfold(Json::Stringify("AllReady", False)));

	declare RazorTime = -1;
	StartTime = Now + 1000;
	EndTime = -1;
	UIManager.UIAll.CountdownEndTime = EndTime;
	SM::UnspawnAllPlayers();

	// Shutdown the poles during warmup
	/*
	foreach (Goal in BlockPoles) {
		Goal.Gauge.Clan = 0;
		Goal.Gauge.Speed = 0;
		Goal.Gauge.Value = 0;
		Goal.Gauge.Max = 1000;
		Goal.Captured = False;
	}*/

	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::PhaseChange;
	UIManager.UIAll.BigMessageSoundVariant = 0;
	UIManager.UIAll.BigMessage = TextLib::Compose("$f90%1", _("Warm-up"));
	UIManager.UIAll.StatusMessage = _("Press F6 once you're ready.");

	// Param: Duration, UseTeam, UseOrder, NumberOfPlayers
	if(S_FreeMode){
		WarmUp::Before(S_WarmUpDuration, True, True, MathLib::NearestInteger(Players.count/2.+1));
	}else{
		WarmUp::Before(S_WarmUpDuration, True, True, C_PlayerNeeded/2);
	}
	
	WarmUp::RestoreOrder();
	G_MapOrder = WarmUp::GetOrder();

	while ((EndTime == -1 || Now <= EndTime) && !ServerShutdownRequested && !MatchEndRequested) {
		yield;
		// Let the server sleep if there's no players on it
		if (PlayersNbTotal <= 0) continue;
		/*
		foreach (Event in PendingEvents) {
			if (Event.Type == CSmModeEvent::EType::OnHit && Event.Victim != Null && Event.WeaponNum == C_WeaponLaser) {
				DisplayHitDistance(Event.Shooter, Event.Victim, True);
			}
		}*/
	
		SpawnThemAll(2);
		SM::UnspawnPlayersChangingClan();
		WarmUp::Loop();
		XmlRpc::Loop();

		if (WarmUp::OrderHasChanged() || WarmUp::ReadyHasChanged()) {
			G_MapOrder = WarmUp::GetOrder();
			UpdateLayerScoresTable(C_SequenceWarmUp);
		}

		//UpdateSpectators();
		// ---------------------------------- //
		// Update the players clublinks
		/*if (S_ForceClublinkTeam1 == "" && S_ForceClublinkTeam2 == "") {
			Clublink::DefineTeamAuto();
			Clublink::Update();
		}*/

		{
			// Warmup ending conditions
			declare SomePlayersReady = CanStartTurn(True);
			declare AllPlayersReady = CanStartTurn(False);

			if (AllPlayersReady == 1 || WarmUp::EndRequested()) {
				if (EndTime == -1 && S_WarmUpDuration <= 0) EndTime = Now;
				else if (EndTime == -1 || EndTime > Now + 5000) EndTime = Now + 5 * 1000;
			} else if (SomePlayersReady == 1) {
				if (RazorTime == -1) RazorTime = Now + S_WarmUpDuration*1000;
				EndTime = RazorTime;
			} else {
				RazorTime = -1;
				EndTime = -1;
			}
		}
	}

	WarmUp::After();

	StartTime = -1;
	EndTime = -1;

	if (MB_UseScriptCallbacks) XmlRpc.SendCallback("EndWarmup", Json::Enfold(Json::Stringify("AllReady", True)));

	//PlaySound(CUIConfig::EUISound::StartMatch, 0);
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
	UIManager.UIAll.StatusMessage = "";
	UIManager.UIAll.BigMessage = "";
	SM::UnspawnAllPlayers();
	// ---------------------------------- //
	// Update the players clublinks
	//if (S_ForceClublinkTeam1 == "" && S_ForceClublinkTeam2 == "") Clublink::DefineTeamAuto();
	//else Clublink::DefineTeamFromUrl(S_ForceClublinkTeam1, S_ForceClublinkTeam2);
	//Clublink::SyncUpdate();

	declare LayerUpdated = Layers::Update("ScoresTable", CreateLayerScoresTable());

	// ---------------------------------- //
	// Play team presentation
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedHidden;
	MB_PlayersPresentationSequence();
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
}


// Update the score summary header.
Void UpdateHeader() {
	declare CSmPlayer Player1 <=> Null;
	declare CSmPlayer Player2 <=> Null;
	declare HeaderClanScores = Integer[Integer];

	HeaderClanScores = [1 => G_MapScores[1], 2 => G_MapScores[2]];

	// Find a captain for each clan
	foreach (Player in Players) {
		if (Player.CurrentClan == 1) {
			Player1 <=> Player;
		} else if (Player.CurrentClan == 2) {
			Player2 <=> Player;
		}
	}

	UIManager.UIAll.OverlayScoreSummary = True;
	if (Player1 != Null) {
		UIManager.UIAll.ScoreSummary_Player1 = Player1.Id;
		UIManager.UIAll.ScoreSummary_Points1 = G_RoundScores[1];
		UIManager.UIAll.ScoreSummary_MatchPoints1 = HeaderClanScores[1];
	} else {
		UIManager.UIAll.ScoreSummary_Player1 = NullId;
		UIManager.UIAll.ScoreSummary_Points1 = 0;
		UIManager.UIAll.ScoreSummary_MatchPoints1 = 0;
	}

	if (Player2 != Null) {
		UIManager.UIAll.ScoreSummary_Player2 = Player2.Id;
		UIManager.UIAll.ScoreSummary_Points2 = G_RoundScores[2];
		UIManager.UIAll.ScoreSummary_MatchPoints2 = HeaderClanScores[2];
	} else {
		UIManager.UIAll.ScoreSummary_Player2 = NullId;
		UIManager.UIAll.ScoreSummary_Points2 = 0;
		UIManager.UIAll.ScoreSummary_MatchPoints2 = 0;
	}
}


// Update the Hud3dMarkers.
Void UpdateMarkers(CSmPlayer Player) {
	// Set the marker above the goals
	foreach (Goal in BlockPoles) {
		declare Name = "";
		declare Type = "";
		declare PosX = Goal.Position.X;
		declare PosY = Goal.Position.Y + 25;
		declare PosZ = Goal.Position.Z;
		declare Set = False;
		if(!Set){
			foreach(PlayerId in G_Team1DefenderPlayers){
				if(Player.Id == PlayerId){
					Set=True;
					if (Goal.Order == 1) {
						Name = "$wDefend";
					} else if (Goal.Order == 2) {
						Name = "";
					}
				}
			}
		}if(!Set){
			foreach(PlayerId in G_Team2DefenderPlayers){
				if(Player.Id == PlayerId){
					Set=True;
					if (Goal.Order == 2) {
						Name = "$wDefend";
					} else if (Goal.Order == 1) {
						Name = "";
					}
				}
			}
		}if(!Set){
			if(Player.Id == G_Team1AttackingPlayer){
				Set=True;
				
				if (Goal.Order == 2) {
					Name = "$wAttack";
				} else if (Goal.Order == 1) {
					Name = "";
				}
			}
		}if(!Set){
			if(Player.Id == G_Team2AttackingPlayer){
				Set=True;
				if (Goal.Order == 1) {
					Name = "$wAttack";
				} else if (Goal.Order == 2) {
					Name = "";
				}
			}
		}
		

		if (Name == "") continue;
		
		declare marker <=> UIManager.UILayerCreate();
		marker.Type = CUILayer::EUILayerType::Markers;

		marker.ManialinkPage ^= """
			<marker {{{Name}}} pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" />
		""";
		UIManager.GetUI(Player).UILayers.add(marker);
	}
}
//Create Marker Layer for Attacker
Text GetMarkerForAttacker(CSmPlayer Player){
	return """<frame id="Marker_{{{TextLib::MLEncode(Player.Login)}}}"><quad sizen="4 4" halign="center" valign="bottom" image="file://Media/Manialinks/ShootMania/Common/LaserWhite.dds" /></frame>""";
}
//Winnings
Void Team1WonAttack(){
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::Capture;
	UIManager.UIAll.BigMessageSoundVariant = 0;
	UIManager.UIAll.StatusMessage = """$<{{{Players[G_Team1AttackingPlayer].Name}}}$> wins the Attack""";
	UIManager.UIAll.SendNotice(
		UIManager.UIAll.StatusMessage,
		CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
		CUIConfig::EUISound::Silence, 0);
	G_LastStatusMessage=Now;
	G_Team1WonAttack=True;
	G_Team2WonDefense=False;
	foreach (Pole in BlockPoles){
		if(Pole.Gauge.Clan == 1){
			Pole.Gauge.ValueReal = 1.0;
		}
	}
	G_Pole1Captured = True;
	G_RoundScores[1]+=1;
	UpdateHeader();
	
}
Void Team2WonAttack(){
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::Capture;
	UIManager.UIAll.BigMessageSoundVariant = 0;
	UIManager.UIAll.StatusMessage = """$<{{{Players[G_Team2AttackingPlayer].Name}}}$> wins the Attack""";
	UIManager.UIAll.SendNotice(
		UIManager.UIAll.StatusMessage,
		CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
		CUIConfig::EUISound::Silence, 0);
	G_LastStatusMessage=Now;
	G_Team2WonAttack=True;
	G_Team1WonDefense=False;
	
	foreach (Pole in BlockPoles){
		if(Pole.Gauge.Clan == 2){
			Pole.Gauge.ValueReal = 1.0;
		}
	}
	G_Pole2Captured = True;
	G_RoundScores[2]+=1;
	UpdateHeader();
}
Void Team1WonDefense(){
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::Warning;
	UIManager.UIAll.BigMessageSoundVariant = 0;
	//UIManager.UIAll.StatusMessage = """$<{{{Teams[0].ColorText}}}{{{Teams[0].Name}}} defense$> stopped $<{{{Players[G_Team2AttackingPlayer].Name}}}$>""";
	UIManager.UIAll.StatusMessage = TextLib::Compose(_("$<%1$> defense stopped $<%2$>"), Teams[0].ColorizedName, Players[G_Team2AttackingPlayer].Name);
	UIManager.UIAll.SendNotice(
		UIManager.UIAll.StatusMessage,
		CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
		CUIConfig::EUISound::Silence, 0);
	G_LastStatusMessage=Now;
	G_Team1WonDefense=True;
	G_Team2WonAttack=False;
}
Void Team2WonDefense(){
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::Warning;
	UIManager.UIAll.BigMessageSoundVariant = 0;
	//UIManager.UIAll.StatusMessage = """$<{{{Teams[1].ColorText}}}{{{Teams[1].Name}}} defense$> stopped $<{{{Players[G_Team1AttackingPlayer].Name}}}$>""";
	UIManager.UIAll.StatusMessage = TextLib::Compose(_("$<%1$> defense stopped $<%2$>"), Teams[1].ColorizedName, Players[G_Team1AttackingPlayer].Name);
	UIManager.UIAll.SendNotice(
		UIManager.UIAll.StatusMessage,
		CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
		CUIConfig::EUISound::Silence, 0);
	G_LastStatusMessage=Now;
	G_Team2WonDefense=True;
	G_Team1WonAttack=False;
}
//ResetPoleUI
Void ResetPoleUI(CSmBlockPole Pole){
	if(Pole.Gauge.Clan == 1){
		G_LastPlayerPoleUI = Players[G_Team1AttackingPlayer];
	}
	else if(Pole.Gauge.Clan == 2){
		G_LastPlayerPoleUI = Players[G_Team2AttackingPlayer];
	}
	G_LastPoleUI=Now;
}
Void ResetPoleUIPlayer(CSmPlayer Player){
	if(Player!=Null){
		declare UI <=> UIManager.GetUI(Player);
		if (UI != Null) {
			UI.GaugeRatio = -1.;
			UI.GaugeMessage = "";
			UI.GaugeClan = 0;
		}
	}
}
// Increases score points
Void IncreaseScore(Ident _Id, Integer _Points) {
	if (Players.existskey(_Id) && Players[_Id].Score != Null) {
		if(_Points >=0){
			Players[_Id].Score.Points += _Points;
		}else{
			Players[_Id].Score.Points -= -1*_Points;
		}
	}
}

// Get region of users zone path

Text GetRegion(CUser _User) {
	if (_User == Null) {
		return "";
	}
	declare ZonePath = "";
	if (_User.ZonePath != "") {
		declare ExplodeZonePath = TextLib::Split("|", _User.ZonePath);
		if (ExplodeZonePath.existskey(1)) {
			ZonePath = ExplodeZonePath[1];
		}
	}
	if (ZonePath == "") {
		ZonePath = "Other";
	}
	return ZonePath;
}

//StartServer
Void InitGameSettings() {
UseClans = True;
UseForcedClans = True;
//UIManager.UIAll.NoticesFilter_HideMapWarning = True;
SM::SetupDefaultVisibility();
SpawnScreen::CreateRules("Legends", Description, False);
G_MapScores	= [1 => 0, 2 => 0];
G_RoundScores = [1 => 0, 2 => 0];
UpdateHeader();




}
//StartMap
Void InitUI() {
UIManager.UIAll.BigMessage = "";
G_LastBigMessage=0;
G_LastStatusMessage=0;
UIManager.UIAll.StatusMessage = "";
UIManager.UIAll.ScoreTableOnlyManialink = True;

}
Void InitLayers() {
// Layers


LayerScores <=> UIManager.UILayerCreate();
LayerScores.Type = CUILayer::EUILayerType::ScoresTable;
LayerScores.ManialinkPage = CreateLayerScoresTable();
UIManager.UIAll.UILayers.add(LayerScores);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
UIManager.UIAll.ScoreTableOnlyManialink = True;

// Teams layer
LayerTeams <=> UIManager.UILayerCreate();
Interface::SetLayerTeams(LayerTeams);
UIManager.UIAll.UILayers.add(LayerTeams);
// Position layer
LayerPosition <=> UIManager.UILayerCreate();
Interface::SetLayerPosition(LayerPosition);
// Match information layer
LayerInformation <=> UIManager.UILayerCreate();
//LayerInformation.ManialinkPage = GetLayerInformation();
UIManager.UIAll.UILayers.add(LayerInformation);
// Markers layer
LayerMarkers <=> UIManager.UILayerCreate();
LayerMarkers.Type = CUILayer::EUILayerType::Markers;
//LayerMarkers.ManialinkPage = GetMarkersLayerManialink();
UIManager.UIAll.UILayers.add(LayerMarkers);

LayerScores.IsVisible = True;
LayerTeams.IsVisible = True;
LayerInformation.IsVisible = True;
LayerMarkers.IsVisible = True;
LayerScores.ManialinkPage = CreateLayerScoresTable();
// Scores table

}
Void InitValues() {
UseLaserVsBullets = S_UseLaserVsBullets;
G_RoundCounter=0;
UseAmmoBonusOnHit = S_UseAmmoBonusOnHit;
G_RoundScores = [1 => 0, 2 => 0];
}
Void PrepareMatch() {
Score::MatchBegin();
Victory::MatchBegin();

}
Void InitBases() {
log("reset pole and spawns");
	declare Integer clan1;
	declare Integer clan2;
	
	if(G_RoundCounter%2==0){
		clan1=1;
		clan2=2;
	}else{
		clan1=2;
		clan2=1;
	}
	
	foreach (Spawn in BlockSpawns) {
		if(Spawn.Order==1){
			Spawn.Base.Clan=clan1;
			Spawn.Base.IsActive = True;
		}else if(Spawn.Order==2){
			Spawn.Base.Clan=clan2;
			Spawn.Base.IsActive = True;
		}else{
			log("no spawn found");
		}
	}
	
	foreach (Pole in BlockPoles){
		if(Pole.Order==1){
			Pole.Gauge.ValueReal = 0.0;
			Pole.Base.Clan = clan1;
			Pole.Gauge.Clan = clan1;
		}else if(Pole.Order==2){
			Pole.Gauge.ValueReal = 0.0;
			Pole.Base.Clan = clan2;
			Pole.Gauge.Clan = clan2;
		}
		Pole.Gauge.Speed=0;
	}
}

Void InitPoles() {
foreach (Pole in BlockPoles){
	Pole.Gauge.Max = MathLib::NearestInteger(S_CaptureTime * 1000);
}

}
Void StartWarmup() {
	declare Cleaned = WarmUp::CleanOrder();
	if (S_FreeMode == False) {
		declare Filled = WarmUp::FillOrder();
		if (Filled) G_MapOrder = WarmUp::GetOrder();
	}
	log("warmup");
	UseClans = True;
	/*
	if(S_FreeMode){
		WarmUp::Before(S_WarmUpDuration, True, True, 2);
	}else{
		WarmUp::Before(S_WarmUpDuration, True, True, C_PlayerNeeded/2);
	}*/
	
	if(C_UseBots){
		G_BlueBots=S_BlueBots;
		G_RedBots=S_RedBots;
		Users_SetNbFakeUsers(G_BlueBots,G_RedBots);
	}
	DoWarmUp();
	LayerScores.ManialinkPage = CreateLayerScoresTable();
	
}

//StartRound
Void InitRoundValues(){
	StartTime = Now+3500;
	EndTime = StartTime+(S_AttackTimeLimit+S_CaptureTimeLimit)*1000;
	UIManager.UIAll.CountdownEndTime=StartTime+S_AttackTimeLimit*1000;
	G_CapturingPossible = False;
	G_Pole1Captured = False;
	G_Pole2Captured = False;
	G_DefenderTimeToBeRespawned.clear();
	G_DefenderKilledTeam1.clear();
	G_DefenderKilledTeam2.clear();
	G_Team1WonDefense = False;
	G_Team2WonDefense = False;
	G_Team1WonAttack = False;
	G_Team2WonAttack = False;
	G_Playing= False;
}
Void PrepareRound() {
	SM::UnspawnAllPlayers();
	Score::RoundBegin();
	Victory::RoundBegin();
	
}

Void CheckWarmup() {
if(S_FreeMode){
	if(PlayersNbTotal<4){
		StartWarmup();
	}
}else{
	if (PlayersNbTotal < C_PlayerNeeded) {
		StartWarmup();
	}
}


}
Void SetTeams() {
	G_Team1Players.clear();
	G_Team2Players.clear();
	G_PlayingPlayers.clear();
	foreach(Player in Players){
	if(Player.CurrentClan==1){
		if(S_FreeMode || G_Team1Players.count<C_PlayerNeeded/2){
			G_Team1Players.add(Player.Id);
			G_PlayingPlayers.add(Player);
		}
	}else if(Player.CurrentClan==2){
		if(S_FreeMode || G_Team2Players.count<C_PlayerNeeded/2){
			G_Team2Players.add(Player.Id);
			G_PlayingPlayers.add(Player);
		}
	}
	
}

}
Void SetRoles() {
//Team1
G_Team1DefenderPlayers.clear();
G_Team1AttackingPlayer=G_Team1Players[G_Team1Players.count-(G_RoundCounter%G_Team1Players.count)-1];
foreach(PlayerId in G_Team1Players){
	if(PlayerId!=G_Team1AttackingPlayer){
		G_Team1DefenderPlayers.add(PlayerId);
	}
}
//Team2

G_Team2DefenderPlayers.clear();
G_Team2AttackingPlayer=G_Team2Players[G_Team2Players.count-(G_RoundCounter%G_Team2Players.count)-1];
foreach(PlayerId in G_Team2Players){
	if(PlayerId!=G_Team2AttackingPlayer){
		G_Team2DefenderPlayers.add(PlayerId);
	}
}

}
Void SetSpawnsAndPoles() {
	InitBases();
}
Void AnnounceAttackers() {
UIManager.UIAll.BigMessage = """$<{{{Players[G_Team1AttackingPlayer].Name}}}$> VS $<{{{Players[G_Team2AttackingPlayer].Name}}}$>""";
UIManager.UIAll.SendNotice(
		UIManager.UIAll.BigMessage,
		CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
		CUIConfig::EUISound::Silence, 0);
G_LastBigMessage = Now;
}
Void StartPlay() {
	log("startRound "^G_RoundCounter);
	InitRoundValues();
	LayerScores.ManialinkPage = CreateLayerScoresTable();
}
//OnNewPlayer
Void EditUI(CSmPlayer Player) {
declare UI <=> UIManager.GetUI(Player);
if (UI != Null) {
	UI.UILayers.clear();
	UI.UILayers.add(LayerScores);
	UI.UILayers.add(LayerTeams);
	UI.UILayers.add(LayerPosition);
	UI.UILayers.add(LayerInformation);
	UI.UILayers.add(LayerMarkers);
}
}
Void EditValues(CSmPlayer Player) {
/*
	log(ClansNbPlayers[1]^" clans "^ClansNbPlayers[2]);
	if(Players[Player.Id]==Null){
		if(ClansNbPlayers[1]<ClansNbPlayers[2]){
			This.SetPlayerClan(Player, 1);
		}else if(ClansNbPlayers[1]>ClansNbPlayers[2]){
			This.SetPlayerClan(Player, 2);
		}else{
			This.SetPlayerClan(Player, 1);
		}
	}
*/
}
//OnNewSpectator
Void PrepareUIForSpectator(CSmPlayer Spectator) {
// Prepare UI for the new spectator
declare UI <=> UIManager.GetUI(Spectator);
if (UI != Null) {
	UI.UILayers.clear();
	
	// Spectating
	UI.SpectatorForcedClan = -1;
}
}
//PlayLoop
Void UpdateUI(){
	if(Now>= StartTime-3000 && !G_Playing){
		UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
		
		G_Playing = True;
	}
	//Big Message Handle
	if (G_LastBigMessage!=0 && Now >= G_LastBigMessage + C_BigMessageTime) {
		log("BigMessage reset");
		G_LastBigMessage=0;
		UIManager.UIAll.BigMessage = "";
	}
	//Status Message Handle
	if (G_LastStatusMessage!=0 && Now >= G_LastStatusMessage + C_StatusMessageTime) {
		log("StatusMessage reset");
		G_LastStatusMessage=0;
		UIManager.UIAll.StatusMessage = "";
	}
	//PoleUI Handle
	if(G_LastPoleUI!=0 && Now >= G_LastPoleUI + C_PoleUITime){
		declare UI <=> UIManager.GetUI(G_LastPlayerPoleUI);
			if (UI != Null) {
				UI.GaugeRatio = -1.;
				UI.GaugeMessage = "";
				UI.GaugeClan = 0;
			}
	}
}
Void SpawnPlayers() {
	if(Now<=StartTime){
	foreach (Player in G_PlayingPlayers) {
	
	switch (Player.SpawnStatus) {
		case CSmPlayer::ESpawnStatus::NotSpawned: {
			// Player not spawned -> Spawn him!
			//log(Now^" startTime: "^StartTime);
			if (!Player.RequestsSpectate && Player.CurrentClan!=0) {
				SpawnThePlayer(Player);
				//UpdateMarkers(Player);
			} else if(!Player.RequestsSpectate){
				//New Player
				if(ClansNbPlayers[1]<ClansNbPlayers[2]){
					This.SetPlayerClan(Player, 1);
				}else if(ClansNbPlayers[1]>ClansNbPlayers[2]){
					This.SetPlayerClan(Player, 2);
				}else{
					This.SetPlayerClan(Player, 1);
				}
				SpawnThePlayer(Player);
			}
		}
	}
	
	}
	
	}
}
Void HandlePendingEvents() {
foreach (Event in PendingEvents) {
	switch (Event.Type) {
		case CSmModeEvent::EType::OnHit: {
				if (Event.Shooter == Null || Event.Victim == Null) {
					// Discard buggy event
					Discard(Event);
				}else if(Event.Shooter == Event.Victim){
					Discard(Event);
				}else if(Event.Shooter.CurrentClan == Event.Victim.CurrentClan){
					if (S_FriendlyFire) {
							// PassOn team hits
							declare Points = -1;
							Event.ShooterPoints = Points;
							IncreaseScore(Event.Shooter.Id, Points);
							PassOn(Event);
						} else {
							// Discard team hits
							Discard(Event);
						}
			
				}else if(Event.Shooter.CurrentClan != Event.Victim.CurrentClan){
					if(Event.Shooter.Id == G_Team1AttackingPlayer){
						if(Event.Victim.Id == G_Team2AttackingPlayer){
							//Ping Victim
							
							Discard(Event);
						}else{
							G_DefenderKilledTeam2.add(Event.Victim.Id);
							PassOn(Event);
						}
						
					}else if(Event.Shooter.Id == G_Team2AttackingPlayer){
						if(Event.Victim.Id == G_Team1AttackingPlayer){
							//Ping Victim
							
							Discard(Event);
						}else{
							G_DefenderKilledTeam1.add(Event.Victim.Id);
							PassOn(Event);
						}
					}else{
						if(Event.Shooter.CurrentClan == 1){
							if(Event.Victim.Id == G_Team2AttackingPlayer){
								
								PassOn(Event);
							}else{
								//Def vs Def
								G_DefenderTimeToBeRespawned[Event.Victim.Id] = Now + S_DefenderRespawnTime*1000;
								PassOn(Event);
							}
						}
						if(Event.Shooter.CurrentClan ==2){
							if(Event.Victim.Id == G_Team1AttackingPlayer){
								PassOn(Event);
							}else{
								//Def vs Def
								G_DefenderTimeToBeRespawned[Event.Victim.Id] = Now + S_DefenderRespawnTime*1000;
								PassOn(Event);
							}
						}
					}
				}
			}
		case CSmModeEvent::EType::OnArmorEmpty: {
				PassOn(Event);
			}
		case CSmModeEvent::EType::OnCapture: {
				if(Event.BlockPole.Gauge.Clan == 1){
					if(!G_Pole1Captured){
						G_Pole1Captured=True;
						//Attack successfull
						log("Pole 1 captured");
						ResetPoleUI(Event.BlockPole);
						Team1WonAttack();
						PassOn(Event);
					}
				}
				else if(Event.BlockPole.Gauge.Clan == 2){
					if(!G_Pole2Captured){
						G_Pole2Captured=True;
						//Attack successfull
						log("Pole 2 captured");
						ResetPoleUI(Event.BlockPole);
						Team2WonAttack();
						PassOn(Event);
					}
			
				}else{
					Discard(Event);
				}
				
			}
		case CSmModeEvent::EType::OnNearMiss: {
				PassOn(Event);
			}
		case CSmModeEvent::EType::OnPlayerRequestRespawn: {
				PassOn(Event);
			}
		default: {
			PassOn(Event);
		}
	}
}
}
Void ActivateGoal() {
if (Now >= StartTime + S_AttackTimeLimit*1000 && Now<EndTime) {
	if (!G_CapturingPossible) {
		log("Cap time");
		G_CapturingPossible = True;
		UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::PhaseChange;
		UIManager.UIAll.BigMessageSoundVariant = 0;
		UIManager.UIAll.StatusMessage = _("The goal can now be captured.");
		UIManager.UIAll.CountdownEndTime = -1;
		G_LastStatusMessage=Now;
	}
}
}
Void CheckForCapture(){
foreach (Pole in BlockPoles) {
	if (G_CapturingPossible) {
		if((!G_Team1WonAttack && Pole.Gauge.Clan == 1) || (!G_Team2WonAttack && Pole.Gauge.Clan == 2)){
			if(Pole.Sector.PlayersIds.count > 0){
				foreach(PlayerId in Pole.Sector.PlayersIds){
			
					if(Pole.Gauge.Clan == 1 && PlayerId == G_Team1AttackingPlayer){
						declare UI <=> UIManager.GetUI(Players[PlayerId]);
						if (UI != Null) {
							UI.GaugeRatio = Pole.Gauge.ValueReal;
							UI.GaugeMessage = MathLib::FloorInteger(Pole.Gauge.ValueReal * 100)^"%";
							UI.GaugeClan = Players[PlayerId].CurrentClan;
							
						}
						Pole.Gauge.Speed = 1;
					}else if(Pole.Gauge.Clan ==2 && PlayerId == G_Team2AttackingPlayer){
						declare UI <=> UIManager.GetUI(Players[PlayerId]);
						if (UI != Null) {
							UI.GaugeRatio = Pole.Gauge.ValueReal;
							UI.GaugeMessage = MathLib::FloorInteger(Pole.Gauge.ValueReal * 100)^"%";
							UI.GaugeClan = Players[PlayerId].CurrentClan;
						}
						Pole.Gauge.Speed = 1;
					}
				}
			}else{
			Pole.Gauge.Speed=0;
		}
		}else{
			Pole.Gauge.Speed=0;
		}
	}else{
		Pole.Gauge.Speed=0;
	}
}
}
Void RespawnDefender() {
	foreach(PlayerId => Time in G_DefenderTimeToBeRespawned){
	
		if(Time != 0 && Now >= Time){
			SpawnThePlayer(Players[PlayerId]);
			G_DefenderTimeToBeRespawned[PlayerId] = 0;
			
		}
	}
}


Void SetPoints() {
//Check attacker 1
if(!G_Team1WonAttack && Now>=StartTime && Players[G_Team1AttackingPlayer].SpawnStatus==CSmPlayer::ESpawnStatus::NotSpawned && !G_Team2WonDefense){
	Team2WonDefense();
}
//Check attacker 2
if(!G_Team2WonAttack && Now>=StartTime && Players[G_Team2AttackingPlayer].SpawnStatus==CSmPlayer::ESpawnStatus::NotSpawned && !G_Team1WonDefense){
	Team1WonDefense();
}
//Check Defense 1
if(!G_Team2WonAttack && !G_Team1WonDefense){
	if(G_DefenderKilledTeam1.count>=G_Team1DefenderPlayers.count){
		//Attacker2 won
		log("All Def killed");
		Team2WonAttack();
	}
}

//Check Defense 2
if(!G_Team1WonAttack && !G_Team2WonDefense){
	if(G_DefenderKilledTeam2.count>=G_Team2DefenderPlayers.count){
		//Attacker1 won
		log("All Def killed");
		Team1WonAttack();
	}
}

if(G_Team1WonAttack && G_Team2WonAttack){
log("team1 and team2 won attack");
	MB_StopRound = True;
}
if(G_Team1WonAttack && G_Team1WonDefense){
log("team1 won attack and defense");
	MB_StopRound = True;
}
if(G_Team2WonAttack && G_Team2WonDefense){
log("team2 won attack and defense");
	MB_StopRound = True;
}
if(G_Team1WonDefense && G_Team2WonDefense){
log("team1 and team2 won defense");
	MB_StopRound = True;
}

//EndTime
if (!MB_StopRound && Now>=EndTime) {
	G_CapturingPossible = False;
	SM::UnspawnAllPlayers();
	// Round winner found
	foreach(Pole in BlockPoles){
		if(Pole.Gauge.ValueReal<1.0){
			if(Pole.Gauge.Clan==2 && !G_Team2WonAttack && !G_Team1WonDefense){
			log("Pole not cap, team1def win");
				Team1WonDefense();
			}else if(Pole.Gauge.Clan==1 && !G_Team1WonAttack && !G_Team2WonDefense){
			log("Pole not cap, team2def win");
				Team2WonDefense();
			}
		}
		
	}
	
}


}


//EndRound
Void AttributePoints() {
	G_RoundCounter+=1;
}
Void DisplayResults() {
sleep(MathLib::NearestInteger(S_TimeBetweenRounds*1000/2));
foreach(Player in G_PlayingPlayers){
		ResetPoleUIPlayer(Player);
	}
sleep(MathLib::NearestInteger(S_TimeBetweenRounds*1000/2));
}
Void EndMap() {
log("End Map");
if(G_MapScores[1]>=S_MapsToWin){
	G_MapScores = [1 => 0, 2 => 0];
	UpdateHeader();
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::EndRound;
	UIManager.UIAll.BigMessageSoundVariant = 0;
	UIManager.UIAll.BigMessage = TextLib::Compose(_("$<%1$> wins the match!"), Teams[0].ColorizedName);
	UIManager.UIAll.SendNotice(
		UIManager.UIAll.BigMessage,
		CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
		CUIConfig::EUISound::Silence, 0);
	G_LastBigMessage=Now;
	
	
}else if(G_MapScores[2]>=S_MapsToWin){
	G_MapScores = [1 => 0, 2 => 0];
	UpdateHeader();
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::EndRound;
	UIManager.UIAll.BigMessageSoundVariant = 0;
	UIManager.UIAll.BigMessage = TextLib::Compose(_("$<%1$> wins the match!"), Teams[1].ColorizedName);
	UIManager.UIAll.SendNotice(
		UIManager.UIAll.BigMessage,
		CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
		CUIConfig::EUISound::Silence, 0);
	G_LastBigMessage=Now;
}
sleep(MathLib::NearestInteger(S_TimeBetweenRounds*1000));
MB_StopMap = True;

}
Void CheckMapEnd() {
if(G_RoundScores[1]>=S_PointLimitToWin || G_RoundScores[2]>=S_PointLimitToWin){
	if(G_RoundScores[2]>=G_RoundScores[1]+S_PointGapToWin){
		//Team 2 win
		log("Team2 win");
		G_MapScores[2]+=1;
		G_RoundScores = [1 => 0, 2 => 0];
		UpdateHeader();
		EndMap();
		
	}else if(G_RoundScores[1]>=G_RoundScores[2]+S_PointGapToWin){
		//Team 1 win
		log("Team1 win");
		G_MapScores[1]+=1;
		G_RoundScores = [1 => 0, 2 => 0];
		UpdateHeader();
		EndMap();
	}
	}
}
//EndMap
Void EndMapUI() {

}
//EndServer
Void Clean() {
}

